#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO572 Advanced Databases
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Database management systems
\end_layout

\begin_layout Paragraph
Requirements
\end_layout

\begin_layout Standard
Should provide:
\end_layout

\begin_layout Itemize

\series bold
Storage:
\series default
 single, reliable repository of data.
\end_layout

\begin_layout Itemize

\series bold
Transactions:
\series default
 should be atomic, consistent, isolated, durable.
\end_layout

\begin_layout Itemize

\series bold
Data analysis.
\end_layout

\begin_layout Itemize

\series bold
Programming model.
\end_layout

\begin_layout Standard
In a way that is:
\end_layout

\begin_layout Itemize

\series bold
Efficient:
\series default
 not slower than hand-written applications.
\end_layout

\begin_layout Itemize

\series bold
Resilient:
\series default
 should recover from problems.
\end_layout

\begin_layout Itemize

\series bold
Robust:
\series default
 predictable performance.
\end_layout

\begin_layout Itemize

\series bold
Scalable:
\series default
 use resources efficiently.
\end_layout

\begin_layout Itemize

\series bold
Concurrent:
\series default
 serve multiple simultaneous clients transparently.
\end_layout

\begin_layout Subsubsection*
Internals
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/db-components.png
	width 50text%

\end_inset


\end_layout

\begin_layout Paragraph
Usage Models
\end_layout

\begin_layout Itemize

\series bold
OLTP:
\series default
 online transaction processing: lots of small updates - want high throughput,
 ACID guarantees.
\end_layout

\begin_layout Itemize

\series bold
OLAP:
\series default
 online analytical processing: running a single data analysis task - want
 low latency, queries are ad-hoc.
\end_layout

\begin_layout Itemize

\series bold
Reporting:
\series default
 running many data analysis tasks in a fixed time - want good resource efficienc
y, queries known in advance.
\end_layout

\begin_layout Itemize

\series bold
HTAP:
\series default
 hybrid transactional/analytical processing.
\end_layout

\begin_layout Section
Storage
\end_layout

\begin_layout Paragraph
Storage manager
\end_layout

\begin_layout Standard
Needs to implement (at least):
\end_layout

\begin_layout Enumerate
Insert tuple.
\end_layout

\begin_layout Enumerate
Delete tuple by key.
\end_layout

\begin_layout Enumerate
Find tuple by key.
\end_layout

\begin_layout Paragraph
N-ary storage model
\end_layout

\begin_layout Itemize
Simply store full tuples in a vector.
\end_layout

\begin_layout Itemize
Insertion is as simple (append the tuple).
\end_layout

\begin_layout Itemize
Data locality is bad when retrieving.
\end_layout

\begin_layout Paragraph
Decomposed storage modeld
\end_layout

\begin_layout Itemize
Each column stored in a separate vector.
\end_layout

\begin_layout Itemize
Insertion now requires decomposition.
\end_layout

\begin_layout Itemize
Retrieving a single tuple requires reconstructing.
\end_layout

\begin_layout Paragraph
Metadata
\end_layout

\begin_layout Itemize
If the table is 
\emph on
dense
\emph default
 (all keys are consecutive), we can have constant lookups.
\end_layout

\begin_layout Itemize
If the table is 
\emph on
sorted
\emph default
, we can use binary search.
\end_layout

\begin_layout Section
Joins
\end_layout

\begin_layout Paragraph
Nested loop joins
\end_layout

\begin_layout Itemize
Sequential I/O
\end_layout

\begin_layout Itemize
Trivial to parallelize (no dependent loop iterations)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|left|\times|right|)$
\end_inset

 with average effort of 
\begin_inset Formula $\frac{{|left|\times|right|}}{2}$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Paragraph
Sort-Merge Joins
\end_layout

\begin_layout Itemize
Sequential I/O in the merge phase
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|left|\times\log|left|+|right|\times\log|right|+|left|+|right|)$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Itemize
Works for inequality joins
\end_layout

\begin_layout Paragraph
Hash Joins
\end_layout

\begin_layout Standard
build-side 
\begin_inset Formula $\equiv$
\end_inset

 buffered side in the hashtable, probe-side 
\begin_inset Formula $\equiv$
\end_inset

 lookup the hashtable.
\end_layout

\begin_layout Itemize

\series bold
Hash function (CRC32, MurmurHash, Modulo-Division) requirements:
\series default
 
\bar under
pure
\bar default
 and 
\bar under
known
\bar default
, 
\bar under
contiguous
\bar default
 output domain.
 Nice to property to have: uniform
\end_layout

\begin_layout Itemize

\series bold
Handling conflicts requirements:
\series default
 Locality (to a certain extent), no holes (probe all the output domain)
\end_layout

\begin_layout Itemize
Sequential I/O the input.
 Parallelizable on probe side, research on build side
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|build|\times|probe|)$
\end_inset

 in the worst case, 
\begin_inset Formula $\Theta(|build|+|probe|)$
\end_inset

 in the best
\end_layout

\begin_layout Itemize

\series bold
Disadvantages: 
\series default
wastes space (over-allocated by 2), people generally rehash (not hole-free),
 hashing costs lots of CPU cycles (can be more expensive than memory), hashtable
s are probed randomly.
\end_layout

\begin_layout Paragraph
Probing strategies:
\end_layout

\begin_layout Standard
Consider the distance from the original conflict
\end_layout

\begin_layout Itemize

\series bold
Linear probing:
\series default
 try increasing distance by 1 until no conflict, leads to long probe chains
\end_layout

\begin_layout Itemize

\series bold
Quadratic probing:
\series default
 try doubling the distance until no conflict, good locality on first three
 probes and bad after, still likely to incur conflicts on first probes
\end_layout

\begin_layout Itemize

\series bold
Cyclic group probing:
\series default
 Generate a sequence of numbers while making sure every number in range
 is generated.
 
\begin_inset Formula $f(x)=(x\times g)\mod n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the size of the hashtable such that 
\begin_inset Formula $n=p^{k}$
\end_inset

, 
\begin_inset Formula $p$
\end_inset

 odd prime, 
\begin_inset Formula $\Rightarrow\exists g({primitive\;roots})$
\end_inset

 of 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Paragraph
Partitioning
\end_layout

\begin_layout Standard
To make one relation much smaller than the other to fit in the buffer pool.
 Make use of the fact that sequential access is much cheaper than random
 access.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/partitioning.png
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
The buffer pool above needs only to hold 5 pages at a time before flushing
 them to disk 
\begin_inset Formula $\Rightarrow$
\end_inset

 sequential I/O in partitioning.
 If partitioning is applied to the probe side to in such a way that matching
 tuples hash to the same value as the probe side then that will reduce massively
 the amount of work to do.
\end_layout

\begin_layout Paragraph
Block Nested Loop Joins
\end_layout

\begin_layout Standard
Simply brings better I/O behavior to NLJs, properties are similar otherwise.
\end_layout

\begin_layout Paragraph
Indexed Nested Loop Joins
\end_layout

\begin_layout Standard
One side has an index, scan over the other side and use the index to get
 the matching tuple
\end_layout

\begin_layout Itemize
Sequential I/O on the unindexed side, 
\bar under
Quasi
\bar default
-random on the indexed side
\end_layout

\begin_layout Itemize
Parallelizable over the values on the unindexed side
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|unidexed|\times|\log indexed|)$
\end_inset

, 
\begin_inset Formula $O(|left|\times|right|)$
\end_inset


\end_layout

\begin_layout Paragraph
Which algorithm to use
\end_layout

\begin_layout Itemize

\series bold
Sort-Merge join:
\series default
 if relations are sorted or have similar sizes.
 Or if evaluating inequality-joins
\end_layout

\begin_layout Itemize

\series bold
Index nested loops:
\series default
 if one relation has an index
\end_layout

\begin_layout Itemize

\series bold
Hashjoin 
\series default
if one relation is much smaller than the other (less than 10%)
\end_layout

\begin_layout Itemize

\series bold
Nested loops
\series default
 if one relation is tiny (
\begin_inset Formula $<20$
\end_inset

 values)
\end_layout

\begin_layout Itemize

\series bold
Block nested
\series default
 loops join for theta-joins
\end_layout

\begin_layout Section
Concurrency Control
\end_layout

\begin_layout Standard
DBMS implements indivisible tasks (
\emph on
transactions
\emph default
):
\end_layout

\begin_layout Enumerate

\emph on
Atomicity
\emph default
: all or nothing.
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: consistent before 
\begin_inset Formula $\rightarrow$
\end_inset

 consistent after.
\end_layout

\begin_layout Enumerate

\emph on
Isolation
\emph default
: independent of any other transaction.
\end_layout

\begin_layout Enumerate

\emph on
Durability
\emph default
: completed transactions are durable.
\end_layout

\end_body
\end_document
