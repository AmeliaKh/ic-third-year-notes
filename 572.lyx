#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO572 Advanced Databases
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Database management systems
\end_layout

\begin_layout Paragraph
Requirements
\end_layout

\begin_layout Standard
Should provide:
\end_layout

\begin_layout Itemize

\series bold
Storage:
\series default
 single, reliable repository of data.
\end_layout

\begin_layout Itemize

\series bold
Transactions:
\series default
 should be atomic, consistent, isolated, durable.
\end_layout

\begin_layout Itemize

\series bold
Data analysis.
\end_layout

\begin_layout Itemize

\series bold
Programming model.
\end_layout

\begin_layout Standard
In a way that is:
\end_layout

\begin_layout Itemize

\series bold
Efficient:
\series default
 not slower than hand-written applications.
\end_layout

\begin_layout Itemize

\series bold
Resilient:
\series default
 should recover from problems.
\end_layout

\begin_layout Itemize

\series bold
Robust:
\series default
 predictable performance.
\end_layout

\begin_layout Itemize

\series bold
Scalable:
\series default
 use resources efficiently.
\end_layout

\begin_layout Itemize

\series bold
Concurrent:
\series default
 serve multiple simultaneous clients transparently.
\end_layout

\begin_layout Subsubsection*
Internals
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/db-components.png
	width 50text%

\end_inset


\end_layout

\begin_layout Paragraph
Usage Models
\end_layout

\begin_layout Itemize

\series bold
OLTP:
\series default
 online transaction processing: lots of small updates - want high throughput,
 ACID guarantees.
\end_layout

\begin_layout Itemize

\series bold
OLAP:
\series default
 online analytical processing: running a single data analysis task - want
 low latency, queries are ad-hoc.
\end_layout

\begin_layout Itemize

\series bold
Reporting:
\series default
 running many data analysis tasks in a fixed time - want good resource efficienc
y, queries known in advance.
\end_layout

\begin_layout Itemize

\series bold
HTAP:
\series default
 hybrid transactional/analytical processing.
\end_layout

\begin_layout Section
Storage
\end_layout

\begin_layout Paragraph
Storage manager
\end_layout

\begin_layout Standard
Needs to implement (at least):
\end_layout

\begin_layout Enumerate
Insert tuple.
\end_layout

\begin_layout Enumerate
Delete tuple by key.
\end_layout

\begin_layout Enumerate
Find tuple by key.
\end_layout

\begin_layout Paragraph
N-ary storage model
\end_layout

\begin_layout Itemize
Simply store full tuples in a vector.
\end_layout

\begin_layout Itemize
Insertion is as simple (append the tuple).
\end_layout

\begin_layout Itemize
Data locality is bad when retrieving.
\end_layout

\begin_layout Paragraph
Decomposed storage modeld
\end_layout

\begin_layout Itemize
Each column stored in a separate vector.
\end_layout

\begin_layout Itemize
Insertion now requires decomposition.
\end_layout

\begin_layout Itemize
Retrieving a single tuple requires reconstructing.
\end_layout

\begin_layout Paragraph
Metadata
\end_layout

\begin_layout Itemize
If the table is 
\emph on
dense
\emph default
 (all keys are consecutive), we can have constant lookups.
\end_layout

\begin_layout Itemize
If the table is 
\emph on
sorted
\emph default
, we can use binary search.
\end_layout

\begin_layout Section
Joins
\end_layout

\begin_layout Paragraph
Nested loop joins
\end_layout

\begin_layout Itemize
Sequential I/O
\end_layout

\begin_layout Itemize
Trivial to parallelize (no dependent loop iterations)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|left|\times|right|)$
\end_inset

 with average effort of 
\begin_inset Formula $\frac{{|left|\times|right|}}{2}$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Paragraph
Sort-Merge Joins
\end_layout

\begin_layout Itemize
Sequential I/O in the merge phase
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|left|\times\log|left|+|right|\times\log|right|+|left|+|right|)$
\end_inset

 assuming uniqueness
\end_layout

\begin_layout Itemize
Works for inequality joins
\end_layout

\begin_layout Paragraph
Hash Joins
\end_layout

\begin_layout Standard
build-side 
\begin_inset Formula $\equiv$
\end_inset

 buffered side in the hashtable, probe-side 
\begin_inset Formula $\equiv$
\end_inset

 lookup the hashtable.
\end_layout

\begin_layout Itemize

\series bold
Hash function (CRC32, MurmurHash, Modulo-Division) requirements:
\series default
 
\bar under
pure
\bar default
 and 
\bar under
known
\bar default
, 
\bar under
contiguous
\bar default
 output domain.
 Nice to property to have: uniform
\end_layout

\begin_layout Itemize

\series bold
Handling conflicts requirements:
\series default
 Locality (to a certain extent), no holes (probe all the output domain)
\end_layout

\begin_layout Itemize
Sequential I/O the input.
 Parallelizable on probe side, research on build side
\end_layout

\begin_layout Itemize
\begin_inset Formula $O(|build|\times|probe|)$
\end_inset

 in the worst case, 
\begin_inset Formula $\Theta(|build|+|probe|)$
\end_inset

 in the best
\end_layout

\begin_layout Itemize

\series bold
Disadvantages: 
\series default
wastes space (over-allocated by 2), people generally rehash (not hole-free),
 hashing costs lots of CPU cycles (can be more expensive than memory), hashtable
s are probed randomly.
\end_layout

\begin_layout Paragraph
Probing strategies:
\end_layout

\begin_layout Standard
Consider the distance from the original conflict
\end_layout

\begin_layout Itemize

\series bold
Linear probing:
\series default
 try increasing distance by 1 until no conflict, leads to long probe chains
\end_layout

\begin_layout Itemize

\series bold
Quadratic probing:
\series default
 try doubling the distance until no conflict, good locality on first three
 probes and bad after, still likely to incur conflicts on first probes
\end_layout

\begin_layout Itemize

\series bold
Cyclic group probing:
\series default
 Generate a sequence of numbers while making sure every number in range
 is generated.
 
\begin_inset Formula $f(x)=(x\times g)\mod n$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the size of the hashtable such that 
\begin_inset Formula $n=p^{k}$
\end_inset

, 
\begin_inset Formula $p$
\end_inset

 odd prime, 
\begin_inset Formula $\Rightarrow\exists g({primitive\;roots})$
\end_inset

 of 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Paragraph
Partitioning
\end_layout

\begin_layout Standard
To make one relation much smaller than the other to fit in the buffer pool.
 Make use of the fact that sequential access is much cheaper than random
 access.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../tyn/img/partitioning.png
	width 50text%

\end_inset


\end_layout

\begin_layout Standard
The buffer pool above needs only to hold 5 pages at a time before flushing
 them to disk 
\begin_inset Formula $\Rightarrow$
\end_inset

 sequential I/O in partitioning.
 If partitioning is applied to the probe side to in such a way that matching
 tuples hash to the same value as the probe side then that will reduce massively
 the amount of work to do.
\end_layout

\begin_layout Paragraph
Block Nested Loop Joins
\end_layout

\begin_layout Standard
Simply brings better I/O behavior to NLJs, properties are similar otherwise.
\end_layout

\begin_layout Paragraph
Indexed Nested Loop Joins
\end_layout

\begin_layout Standard
One side has an index, scan over the other side and use the index to get
 the matching tuple
\end_layout

\begin_layout Itemize
Sequential I/O on the unindexed side, 
\bar under
Quasi
\bar default
-random on the indexed side
\end_layout

\begin_layout Itemize
Parallelizable over the values on the unindexed side
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Theta(|unidexed|\times|\log indexed|)$
\end_inset

, 
\begin_inset Formula $O(|left|\times|right|)$
\end_inset


\end_layout

\begin_layout Paragraph
Which algorithm to use
\end_layout

\begin_layout Itemize

\series bold
Sort-Merge join:
\series default
 if relations are sorted or have similar sizes.
 Or if evaluating inequality-joins
\end_layout

\begin_layout Itemize

\series bold
Index nested loops:
\series default
 if one relation has an index
\end_layout

\begin_layout Itemize

\series bold
Hashjoin 
\series default
if one relation is much smaller than the other (less than 10%)
\end_layout

\begin_layout Itemize

\series bold
Nested loops
\series default
 if one relation is tiny (
\begin_inset Formula $<20$
\end_inset

 values)
\end_layout

\begin_layout Itemize

\series bold
Block nested
\series default
 loops join for theta-joins
\end_layout

\begin_layout Section
Bulk Processing
\end_layout

\begin_layout Standard
Turn 
\bar under
control dependencies
\bar default
 into 
\bar under
data dependencies
\bar default
.
 No function calls (no jumps 
\begin_inset Formula $\Rightarrow$
\end_inset

 CPU efficient).
\end_layout

\begin_layout Quote
Page access probability from selectivity: 
\begin_inset Formula $1-(1-s)^{n}$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Materialise all:
\series default
 write down entire tuple in output array on each operator
\end_layout

\begin_layout Itemize

\series bold
By reference:
\series default
 Return array of reference to the Tuples in the table.
 
\end_layout

\begin_layout Itemize

\series bold
By reference using column storage (DSM):
\series default
 Same idea but optimises predicate evaluation by having more values fit
 on a page
\end_layout

\begin_layout Section
Secondary Storage
\end_layout

\begin_layout Subsection
Indexes
\end_layout

\begin_layout Itemize

\series bold
Clustered or Primary Index:
\series default
 store the tuples of a table, at most 1
\end_layout

\begin_layout Itemize

\series bold
Unclustered or Secondary Index:
\series default
 store pointers to the tuples of a table
\end_layout

\begin_layout Paragraph
Hash indexing
\end_layout

\begin_layout Standard
Hash table 
\begin_inset Formula $<\text{{Key}, \text{{Position}>}}$
\end_inset

 
\end_layout

\begin_layout Itemize

\series bold
Maintenance: 
\series default
Overallocated, need to rebuild if fill factor is too high (expensive even
 with 
\bar under
consistent hashing
\bar default
), on delete need to put a marker in the hashtable for future probing, load
 spikes
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Equijoins/aggregation on specific keys, filter on specific keys
\end_layout

\begin_layout Paragraph
Bitmap indexing
\end_layout

\begin_layout Standard
A bitvector for each distinct value in a column (few distinct values) 
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Can reduce bandwidth needed for scanning a column, can be compressed even
 further, can use arbitrary conditions (make disjoint sets of values called
 
\bar under
binned bitmaps
\bar default
)
\end_layout

\begin_layout Itemize

\series bold
Run-length encoding: 
\series default
replace consecutive occurrences with length of the chain, works well on
 high locality data, requires sequential scan to find values at a specific
 position
\end_layout

\begin_layout Paragraph
Foreign-Key indices
\end_layout

\begin_layout Standard
Specifies that there is 
\bar under
exactly one
\series bold
\bar default
 
\series default
value in the PK column of the other table
\end_layout

\begin_layout Itemize
Need to maintain integrity, DBMS on insert/update need to make sure the
 value doesn't already exist
\end_layout

\begin_layout Itemize
Implemented using a pointer because it means it joins to exactly one row
\end_layout

\begin_layout Itemize

\series bold
Usefulness: Low space requirement, instant joins, insignificant effort added
 on insert/update.

\series default
 But can't be used for anything else
\end_layout

\begin_layout Paragraph
B-Trees
\end_layout

\begin_layout Standard
Reduce load spikes by using a tree
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Support ranges, self balancing 
\end_layout

\begin_layout Itemize

\series bold
Disadvantages:
\series default
 Complex, leaf pointers aren't used, most of the data lives in the leaf
 nodes but not all of it (need to go up)
\end_layout

\begin_layout Paragraph
B+-Trees
\end_layout

\begin_layout Standard
Keep all key and pointers to data in the leaf nodes, replicate the keys
 above, link the leaves like a linked list.
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 balancing is same effort, dense index at the bottom (sequential access),
 scans over ranges are trivial
\end_layout

\begin_layout Subsection
Materialized views
\end_layout

\begin_layout Itemize
\begin_inset Formula $\equiv$
\end_inset

 alias to a query.
 However some systems actually stores the result of the query and modify
 it on modifications of the underlying relations (expensive).
\end_layout

\begin_layout Itemize

\series bold
Usefulness:
\series default
 Running the same query returns result instantaneously, some systems are
 smart in reusing part of the views to save on computation
\end_layout

\begin_layout Section
Query Planning and Optimisation
\end_layout

\begin_layout Standard
Start with a correct plan and apply 
\bar under
equivalence
\bar default
 rules (keep correctness, and hopefully improve performance)
\end_layout

\begin_layout Itemize
Work on sub-plan like divide and conquer.
 From the root of the plan, apply pattern to start new plan and start process
 again until you traverse without applying any transformation
\end_layout

\begin_layout Itemize

\series bold
Logical
\series default
 
\begin_inset Formula $\equiv$
\end_inset

 algorithm-agnostic, 
\series bold
Physical
\series default
 
\begin_inset Formula $\equiv$
\end_inset

 algorithm-aware, 
\series bold
Rule-based
\series default
 
\begin_inset Formula $\equiv$
\end_inset

 data-agnostic, 
\series bold
Cost-based
\series default
 
\begin_inset Formula $\equiv$
\end_inset

 data-aware
\end_layout

\begin_layout Paragraph
Logical rule-based optimization
\end_layout

\begin_layout Standard
Perform on relational algebra (portable), but often wrong, infinite cycles,
 missing rule problem as show here:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename ../tyn/img/optimisation_1.png
	width 50text%

\end_inset


\begin_inset Graphics
	filename ../tyn/img/optimisation_2.png
	width 50text%

\end_inset


\end_layout

\begin_layout Itemize
Selection and projection 
\series bold
pushed
\series default
 through joins if only applied to one side
\end_layout

\begin_layout Itemize

\series bold
Operator reordering
\series default
 (joins, selection, unions) like 
\begin_inset Formula $s(==)<s(<)<s(<>)$
\end_inset

 (that example is a 
\bar under
guard
\bar default
 too to avoid infinite loop in optimisation when swapping 2 selections),
 reorder selects based on type
\end_layout

\begin_layout Paragraph
Cost based optimisation
\end_layout

\begin_layout Standard
Cost metric here will be number of tuples produced
\end_layout

\begin_layout Itemize
Estimations: like selecting one value: 
\begin_inset Formula $\frac{{1}}{\text{\text{{disctinct\;values\;in\;column}}}}$
\end_inset

 and recording distinct values, can be very off (e.g.
 booleans)
\end_layout

\begin_layout Itemize

\series bold
Statistics
\series default
: histograms 
\begin_inset Formula $\frac{\text{{occurence\;value} }}{\text{{total\;tuple\;count}}}$
\end_inset

 and evaluate query on histogram first, multidimensional histograms to resolve
 attribute correlation
\end_layout

\begin_layout Paragraph
Physical optimisation
\end_layout

\begin_layout Itemize

\series bold
Example metrics:
\series default
 # volcano function calls, sum of all produced tuples (incl.
 materializations), number of Page Faults (I/O), CPU costs, max(I/O, CPU),
 total intermediate size
\end_layout

\begin_layout Itemize

\series bold
Counting cost is hard:
\series default
 different algorithms have different costs on all the above, how do you
 weight them? e.g.
 
\bar under
Nested Loop join:
\bar default
 less space, no hash, more comparisons
\end_layout

\begin_layout Paragraph
Rule based physical optimisation
\end_layout

\begin_layout Standard
Focused on hardware (parallelism, cache-conscious partitioning), or selecting
 join algorithms like we discussed above.
\end_layout

\begin_layout Paragraph
Cost-based physical optimisation
\end_layout

\begin_layout Standard
Generally access path selection (read data from indexes? straight from table?
 from materialised view?)
\end_layout

\begin_layout Section
Distributed databases
\end_layout

\begin_layout Paragraph
CAP theory
\end_layout

\begin_layout Standard
No distributed system can maintain all three:
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: all nodes see the same version of data.
\end_layout

\begin_layout Enumerate

\emph on
Availability
\emph default
: system always responds within fixed upper limit of time.
\end_layout

\begin_layout Enumerate

\emph on
Partition tolerance
\emph default
: system always gives correct response even when messages are lost.
\end_layout

\begin_layout Paragraph
Approaches
\end_layout

\begin_layout Enumerate

\emph on
Heterogeneous DDB
\emph default
: varied database techology, managed by different DBAs, designed at different
 times.
\end_layout

\begin_deeper
\begin_layout Itemize
Requires a 
\emph on
commmon data model
\end_layout

\begin_layout Itemize
Need to perform 
\emph on
schema integration
\emph default
.
\end_layout

\begin_layout Enumerate
Transform 
\emph on
local schemas
\emph default
 to a standard data modelling language.
\end_layout

\begin_layout Enumerate
Filter to get 
\emph on
export schemas
\emph default
.
\end_layout

\begin_layout Enumerate
Construct 
\emph on
global schemas
\emph default
.
\end_layout

\begin_layout Enumerate
Filter to get 
\emph on
external schema
\emph default
 for applications.
\end_layout

\begin_layout Itemize

\emph on
Data warehouse
\emph default
: materialise copies of data with global schema.
\end_layout

\begin_layout Itemize

\emph on
Mediator architecture
\emph default
: gives live results, but higher latency and demand on systems.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Homogeneous DDB
\emph default
: same technology, one DBA, designed at same time.
\end_layout

\begin_deeper
\begin_layout Itemize
Different sites each have 
\emph on
local schema
\emph default
.
\end_layout

\begin_layout Itemize
Combine to form a single 
\emph on
global schema
\emph default
.
\end_layout

\begin_layout Itemize
Different 
\emph on
external schemas
\emph default
 for different applications.
\end_layout

\end_deeper
\begin_layout Paragraph
Fragmentation / sharding
\end_layout

\begin_layout Standard
Split data objects between sites, queries and updates correspondingly distribute
d.
\end_layout

\begin_layout Itemize
Usually less reliable (each database can go down).
\end_layout

\begin_layout Itemize
Usually faster (parallelism in horizontal fragmentation).
\end_layout

\begin_layout Enumerate

\emph on
Horizontal fragmentation
\emph default
:
\begin_inset Formula 
\[
R=R_{1}\cup\dots\cup R_{n}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Split rows using 
\begin_inset Formula $\sigma$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=\sigma_{P_{1}}R,\dots,R_{n}=\sigma_{P_{n}}R
\]

\end_inset


\end_layout

\begin_layout Itemize
Derived horizontal fragmentation splits rows using 
\begin_inset Formula $\ltimes$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=R\ltimes S_{1},\dots,R\ltimes S_{n}
\]

\end_inset


\end_layout

\begin_layout Itemize
Fragmentation rules:
\end_layout

\begin_deeper
\begin_layout Enumerate
Must cover all possible values.
\end_layout

\begin_layout Enumerate
Should not involve things that change!
\end_layout

\begin_layout Enumerate
Should be easy to fragment on.
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate

\emph on
Vertical fragmentation
\emph default
: A loss-less join decomposition:
\begin_inset Formula 
\[
R=R_{1}\bowtie\dots\bowtie R_{n}
\]

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Splits rows using 
\begin_inset Formula $\pi$
\end_inset

:
\begin_inset Formula 
\[
R_{1}=\pi_{\text{attrs}_{1}}R,\dots,R_{n}=\pi_{\text{attrs}_{n}}R
\]

\end_inset


\end_layout

\begin_layout Itemize
Fragmentation rule should include a key.
\end_layout

\end_deeper
\begin_layout Paragraph
Replication
\end_layout

\begin_layout Standard
Copy data objects between sites.
\end_layout

\begin_layout Itemize
Queries may run on any site.
\end_layout

\begin_layout Itemize
Updates must be written to all sites.
\end_layout

\begin_layout Itemize
Usually more reliable (individual copies may go down).
\end_layout

\begin_layout Itemize
Usually faster (by reducing load on each site).
\end_layout

\begin_layout Paragraph
Migration
\end_layout

\begin_layout Standard
Move data to where its used.
\end_layout

\begin_layout Section
Big data
\end_layout

\begin_layout Paragraph
Data models
\end_layout

\begin_layout Itemize

\emph on
Key-value.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Very limited querying capabalities.
\end_layout

\begin_layout Itemize
Useful for caching.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Document store
\emph default
: document (semi-structured) data model (e.g.
 JSON).
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Support queries searching field values.
\end_layout

\begin_layout Itemize
Use MapReduce for OLAP.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Wide column
\emph default
: table data model with easy addition of new columns.
 Columns may be put in families.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Support queries searching field values.
\end_layout

\begin_layout Itemize
Use MapReduce for OLAP.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Relational
\emph default
: relational data model.
\end_layout

\begin_deeper
\begin_layout Itemize
Schema based.
\end_layout

\begin_layout Itemize
Support queries searching fields and performing joins.
\end_layout

\begin_layout Itemize
ACID properties of transactions.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Graph
\emph default
: nodes and edges (e.g.
 RDF).
\end_layout

\begin_deeper
\begin_layout Itemize
Schema-less.
\end_layout

\begin_layout Itemize
Limited querying possible.
\end_layout

\end_deeper
\begin_layout Paragraph
MapReduce
\end_layout

\begin_layout Enumerate

\emph on
Load
\emph default
: items from data nodes to Map nodes.
\end_layout

\begin_layout Enumerate

\emph on
Map
\emph default
: nodes perform map function on each item.
\end_layout

\begin_layout Enumerate

\emph on
Combine
\emph default
: partially calculate the Reduce on the Map nodes.
\end_layout

\begin_layout Enumerate

\emph on
Shuffle
\emph default
: send each item to the correct Reduce node.
\end_layout

\begin_layout Enumerate

\emph on
Reduce
\emph default
: nodes perform reduction function on incoming items.
\end_layout

\begin_layout Paragraph
Pig Latin
\end_layout

\begin_layout Itemize

\emph on
Load
\emph default
: make data source available as relation:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account = LOAD 'file.tsv'
\end_layout

\begin_layout Plain Layout

          AS (no:int, type:chararray, rate:float);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Strore
\emph default
: execute script and store result:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

STORE account INTO 'copy' USING PigStorage(',');
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Project
\emph default
: 
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

rate = FOREACH account GENERATE rate;
\end_layout

\begin_layout Plain Layout

distinct_rate = DISTINCT rate;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Filter
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_with_rate = FILTER account BY rate > 0.0;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Cross
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

branch_with_account = CROSS branch, account;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Equi-join
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

branch_and_account = JOIN branch BY sortcode
\end_layout

\begin_layout Plain Layout

                           account BY sortcode;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Union
\emph default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

id = UNION branch_sortcode, account_no;
\end_layout

\begin_layout Plain Layout

distinct_id = DISTINCT id;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Difference
\emph default
: use a left join:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_and_movement = JOIN account BY no LEFT,
\end_layout

\begin_layout Plain Layout

                            movement BY no;
\end_layout

\begin_layout Plain Layout

account_without_movement = 
\end_layout

\begin_layout Plain Layout

    FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

    BY movement::no IS NULL;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Group by
\emph default
: produces a 
\family typewriter
group
\family default
 column with the grouped-on value and a column containing a 
\emph on
bag
\emph default
 of tuples belonging to each group.
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_movements = GROUP movement BY no;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Flatten
\emph default
: generate a row for each tuple in a bag:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

movement_copy = FOREACH account_movements
\end_layout

\begin_layout Plain Layout

                GENERATE FLATTEN(movement);
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Aggregation
\emph default
: 
\family typewriter
COUNT(a)
\family default
, 
\family typewriter
COUNT_STAR(a)
\family default
, 
\family typewriter
AVG(a)
\family default
, 
\family typewriter
MAX(a)
\family default
, 
\family typewriter
MIN(a)
\family default
, 
\family typewriter
SUM(a)
\family default
, or 
\family typewriter
DIFF(a, b)
\family default
:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

movement_copy =
\end_layout

\begin_layout Plain Layout

    FOREACH account_movements
\end_layout

\begin_layout Plain Layout

    GENERATE group AS no, 
\end_layout

\begin_layout Plain Layout

             SUM(movement.amount) AS balance;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\emph on
Cases
\emph default
: Use nested statements:
\family typewriter

\begin_inset listings
lstparams "basicstyle={\ttfamily}"
inline false
status open

\begin_layout Plain Layout

account_credit_and_debit =
\end_layout

\begin_layout Plain Layout

    FOREACH account_detail {
\end_layout

\begin_layout Plain Layout

        credit = FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

                 BY amount > 0.0;
\end_layout

\begin_layout Plain Layout

        debit = FILTER account_and_movement
\end_layout

\begin_layout Plain Layout

                BY amount < 0.0;
\end_layout

\begin_layout Plain Layout

        GENERATE group AS no,
\end_layout

\begin_layout Plain Layout

                 COUNT(account_and_movement) AS ts,
\end_layout

\begin_layout Plain Layout

                 SUM(credit.amount) AS credit,
\end_layout

\begin_layout Plain Layout

                 SUM(debit.amount) AS debit;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Pig optimisations
\end_layout

\begin_layout Enumerate
Project before a 
\family typewriter
GROUP BY
\family default
: less data to handle in the 
\family typewriter
GROUP BY
\family default
.
\end_layout

\begin_layout Paragraph
Pig to MapReduce
\end_layout

\begin_layout Itemize

\family typewriter
FILTER
\family default
 and 
\family typewriter
FOREACH
\family default
 are implemented using Map.
\end_layout

\begin_layout Itemize

\family typewriter
GROUP
\family default
 implemented by a Combine, then Reduce.
\end_layout

\begin_layout Itemize
All others implemented as just a Reduce.
\end_layout

\begin_deeper
\begin_layout Itemize
If a Map process is after a Reduce, it can be put in the Reduce node.
\end_layout

\end_deeper
\begin_layout Paragraph
Distributed hash join
\end_layout

\begin_layout Enumerate
Each Map node generates its bit of each hash bucket.
\end_layout

\begin_layout Enumerate
Reduce gets all files belonging to a particular hash bucket and performs
 join.
\end_layout

\begin_layout Paragraph
Replicated join
\end_layout

\begin_layout Enumerate
Replicate the entire RHS (smaller table) to all Map nodes holding the LHS.
\end_layout

\begin_layout Enumerate
Execute join as a Map process.
\end_layout

\begin_layout Paragraph
Skewed join
\end_layout

\begin_layout Enumerate
Uses a histogram of the frequency of join keys.
\end_layout

\begin_layout Enumerate
Histogram used to distribute the join over Reduce nodes.
 For keys with high frequency in LHS:
\end_layout

\begin_deeper
\begin_layout Enumerate
Distribute rows from LHS using round-robin.
\end_layout

\begin_layout Enumerate
Duplicate rows from RHS to multiple Reduce nodes.
\end_layout

\end_deeper
\begin_layout Paragraph
Merge join
\end_layout

\begin_layout Standard
Assumes both inputs are sorted.
\end_layout

\begin_layout Enumerate
Map nodes of LHS load required blocks from RHS.
\end_layout

\begin_layout Enumerate
Execute sort-merge join as a Map process.
\end_layout

\begin_layout Section
Distributed query processing
\end_layout

\begin_layout Paragraph
DBMS componenets
\end_layout

\begin_layout Enumerate

\emph on
Transaction manager
\emph default
: query processor plans and translates queries.
\end_layout

\begin_layout Enumerate

\emph on
Scheduler
\emph default
: schedules primitive operators to obey ACID properties.
\end_layout

\begin_layout Enumerate

\emph on
Data manager
\emph default
: interacts with memory maintains durability of transactions.
\end_layout

\begin_layout Paragraph
Distribution of transaction processing
\end_layout

\begin_layout Standard
In a DDB:
\end_layout

\begin_layout Itemize
Each site runs a 
\emph on
Local Transaction Manager
\emph default
, scheduler and data manager.
\end_layout

\begin_layout Itemize
One or more sites run a 
\emph on
Global Transaction Manager
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Transforms transaction into sub-transactions for each site.
\end_layout

\end_deeper
\begin_layout Subsubsection*
RA Equivalences
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout

\family typewriter
SELECT
\family default
s over horizontal fragmentation:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/select-horiz-frag.png
	width 80text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout

\family typewriter
JOIN
\family default
s over derived horizontal fragmentation:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/join-horiz-frag.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Always push 
\family typewriter
PROJECT
\family default
s inside 
\family typewriter
JOIN
\family default
:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/project-in-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Always push 
\family typewriter
SELECT
\family default
s inside 
\family typewriter
JOIN
\family default
:
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/select-in-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Direct join (high selectivity) 
\begin_inset Formula $\rightleftarrows$
\end_inset

 semi join (low selectivity):
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/semi-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
Local join 
\begin_inset Formula $\rightleftarrows$
\end_inset

 remote join (denormalises data):
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/remote-join.png
	width 95text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
SQL queries over fragmented data
\end_layout

\begin_layout Itemize

\emph on
Horizontal fragmentation
\emph default
: determined using 
\family typewriter
WHERE
\family default
 clause (
\begin_inset Formula $\sigma$
\end_inset

).
\end_layout

\begin_layout Itemize

\emph on
Vertical fragmentation
\emph default
: determined using 
\family typewriter
SELECT
\family default
 clause (
\begin_inset Formula $\pi$
\end_inset

), but must ensure 
\family typewriter
JOIN
\family default
 and 
\family typewriter
WHERE
\family default
 clauses can be processed.
\end_layout

\begin_layout Section
Concurrency control
\end_layout

\begin_layout Standard
DBMS implements indivisible tasks (
\emph on
transactions
\emph default
):
\end_layout

\begin_layout Enumerate

\emph on
Atomicity
\emph default
: all or nothing.
\end_layout

\begin_layout Enumerate

\emph on
Consistency
\emph default
: consistent before 
\begin_inset Formula $\rightarrow$
\end_inset

 consistent after.
\end_layout

\begin_layout Enumerate

\emph on
Isolation
\emph default
: indepenedent of any other transaction.
\end_layout

\begin_layout Enumerate

\emph on
Durability
\emph default
: completed transactions are durable.
\end_layout

\begin_layout Paragraph
Transaction histories
\end_layout

\begin_layout Standard
For a transaction 
\begin_inset Formula $T_{n}$
\end_inset

:
\end_layout

\begin_layout Enumerate
Begin transaction: 
\begin_inset Formula $b_{n}$
\end_inset

.
\end_layout

\begin_layout Enumerate
Read / write operations on objects: 
\begin_inset Formula $r_{n}\left[o_{j}\right]$
\end_inset

 and 
\begin_inset Formula $w_{n}\left[o_{j}\right]$
\end_inset

.
\end_layout

\begin_layout Enumerate
Commit / abort: 
\begin_inset Formula $c_{n}$
\end_inset

 or 
\begin_inset Formula $a_{n}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Cocurrency control
\end_layout

\begin_layout Standard
Have to ensure:
\end_layout

\begin_layout Enumerate

\emph on
Serialisability
\emph default
: a concurrent execution of transactions should have the same end result
 as some serial execution.
\end_layout

\begin_layout Enumerate

\emph on
Recoverability
\emph default
: no transaction commits depending on data that has been produced by another
 transaction that has yet to commit.
\end_layout

\begin_layout Paragraph
Anomolies
\end_layout

\begin_layout Enumerate

\emph on
Lost update
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

and 
\begin_inset Formula $T_{2}$
\end_inset

 update the same data element and one update is lost (overwritten).
\end_layout

\begin_layout Enumerate

\emph on
Inconsistent analysis
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 acesses data before 
\begin_inset Formula $T_{2}$
\end_inset

 finishes working with that data.
\end_layout

\begin_layout Enumerate

\emph on
Dirty read
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 reads a value that 
\begin_inset Formula $T_{2}$
\end_inset

 has written but not committed.
 Can cause non-recoverability.
\end_layout

\begin_layout Enumerate

\emph on
Dirty write
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 writes to an object that 
\begin_inset Formula $T_{2}$
\end_inset

 has written to but not committed.
 Makes recoverability hard.
\end_layout

\begin_layout Enumerate

\emph on
Phantom read
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 executes two queries, the second returning something different to the first,
 due 
\begin_inset Formula $T_{2}$
\end_inset

 inserting/removing an object.
\end_layout

\begin_layout Enumerate

\emph on
Write skew
\emph default
: 
\begin_inset Formula $T_{1}$
\end_inset

 and 
\begin_inset Formula $T_{2}$
\end_inset

 concurrently read overlapping data and then concurrently make updates.
\end_layout

\begin_layout Paragraph
Conflicts
\end_layout

\begin_layout Standard
An interaction between two transactions:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $r_{x}[o]$
\end_inset

 and 
\begin_inset Formula $w_{y}[o]$
\end_inset

 are in 
\begin_inset Formula $H$
\end_inset

, or
\end_layout

\begin_layout Enumerate
\begin_inset Formula $w_{x}[o]$
\end_inset

 and 
\begin_inset Formula $w_{y}[o]$
\end_inset

 are in 
\begin_inset Formula $H$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula $H_{1}$
\end_inset

 and 
\begin_inset Formula $H_{2}$
\end_inset

 are conflict equivalent if:
\end_layout

\begin_layout Enumerate
They contain the same set of operations, and
\end_layout

\begin_layout Enumerate
Order conflicts (of non-aborted transactions) in the same way.
\end_layout

\begin_layout Standard
\begin_inset Formula $H$
\end_inset

 is conflict serialisable if 
\begin_inset Formula $C\left(H\right)\equiv_{CE}H'$
\end_inset

 where 
\begin_inset Formula $H'$
\end_inset

 is a serial history.
\end_layout

\begin_layout Paragraph
Serialisation graph
\end_layout

\begin_layout Standard
Contains a node for each transaction in 
\begin_inset Formula $H$
\end_inset

, and an edge if there as a conflict from one node to another.
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $SG\left(H\right)$
\end_inset

 is acyclic, then 
\begin_inset Formula $H$
\end_inset

 is conflict serialisable.
\end_layout

\begin_layout Paragraph
Recoverability
\end_layout

\begin_layout Standard
In addition to recoverability, we sometimes want to ensure:
\end_layout

\begin_layout Itemize

\emph on
Avoids cascading aborts
\emph default
: no dirty reads.
\end_layout

\begin_layout Itemize

\emph on
Strict execution
\emph default
: no dirty reads or writes.
\end_layout

\begin_layout Paragraph
Maintaining serialisability and recoverability
\end_layout

\begin_layout Enumerate

\emph on
Two-phase locking
\emph default
: conflict based.
\end_layout

\begin_layout Enumerate

\emph on
Time-stamping
\emph default
: add timestamps to object, only read or write objects with earlier timestamp.
\end_layout

\begin_layout Enumerate

\emph on
Optimistic concurrency control
\emph default
: inspect history for problems at commit.
\end_layout

\begin_layout Paragraph
2PL Protocol
\end_layout

\begin_layout Standard
Every history has a maximum lock period, we must be able to re-time history
 to make all operations take place during that period 
\begin_inset Formula $\implies$
\end_inset

 CSR.
\end_layout

\begin_layout Enumerate

\emph on
Read locks
\emph default
 (non-exclusive).
\end_layout

\begin_layout Enumerate

\emph on
Write locks
\emph default
 (exclusive).
\end_layout

\begin_layout Enumerate

\emph on
Growing
\emph default
 and 
\emph on
shrinking
\emph default
 phase: cannot gain a new lock after releasing a lock.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/2pl-anomolies.png
	width 95text%

\end_inset


\end_layout

\begin_layout Standard
2PL 
\emph on
does not prevent phantom reads / complex write skew
\emph default
s.
 Solutions:
\end_layout

\begin_layout Enumerate

\emph on
Table locks
\emph default
: read lock table when performing a scan:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Can produce needless conflicts.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Efficient if large parts of the table are being updated.
\end_layout

\end_deeper
\begin_layout Enumerate

\emph on
Predicate locking
\emph default
: lock the predicate that the transaction uses.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Difficult to implement.
\end_layout

\end_deeper
\begin_layout Standard
We can get 
\emph on
deadlocks
\emph default
 with 2PL: if WFG has a cycle.
\end_layout

\begin_layout Paragraph
Conservative locking
\end_layout

\begin_layout Standard
Obtain all locks at beginnning.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Prevents deadlock.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Quite difficult to tell what locks required.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Not recoverable.
\end_layout

\begin_layout Paragraph
Strict locking
\end_layout

\begin_layout Standard
Prevent write locks being released before end of transaction.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Prevents dirty reads/writes 
\begin_inset Formula $\implies$
\end_inset

 recoverability.
\end_layout

\begin_layout Itemize
\begin_inset Formula $-$
\end_inset

 Allows deadlock.
\end_layout

\begin_layout Paragraph
Strong strict locking
\end_layout

\begin_layout Standard
All locks released at end of transactions.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Simple to implement.
\end_layout

\begin_layout Itemize
\begin_inset Formula $+$
\end_inset

 Suitable for distributed transactions.
\end_layout

\begin_layout Paragraph
SQL transaction isolation level
\end_layout

\begin_layout Standard

\family typewriter
SET TRANSACTION ISOLATION LEVEL ...
\end_layout

\begin_layout Enumerate

\family typewriter
READ UNCOMMITTED
\family default
 prevents only dirty writes.
\end_layout

\begin_layout Enumerate

\family typewriter
READ COMMITTED
\family default
 prevents dirty reads and writes.
\end_layout

\begin_layout Enumerate

\family typewriter
SNAPSHOT
\family default
 prevents all anomolies except write skew.
\end_layout

\begin_layout Enumerate

\family typewriter
REPEATABLE READ
\family default
 prevents all anomolies except phantom reads.
\end_layout

\begin_layout Enumerate

\family typewriter
SERIALIZABLE
\family default
 implements full serialisability.
\end_layout

\begin_layout Paragraph
Distributed concurrency control
\end_layout

\begin_layout Standard

\emph on
DWFG
\emph default
:
\end_layout

\begin_layout Enumerate
Add spawn double-edges to master.
\end_layout

\begin_layout Enumerate
When a local cycle appears, fetch remote WFG.
\end_layout

\begin_layout Standard

\emph on
Global 2PL
\emph default
: 2PL cannot just be executed at each site:
\end_layout

\begin_layout Enumerate
Use strong strict locking at each site, using a global atomic commit to
 end transaction.
\end_layout

\begin_layout Enumerate

\emph on
Two-phase commit
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Can become blocked.
\end_layout

\end_deeper
\begin_layout Standard
\align center
\begin_inset Graphics
	filename img/2pc.png
	width 95text%

\end_inset


\end_layout

\begin_layout Standard

\emph on
Distributed locking
\emph default
: for 
\begin_inset Formula $n$
\end_inset

 sites, 
\end_layout

\begin_layout Itemize

\emph on
Write-write conflicts
\emph default
: at least 
\begin_inset Formula $\left\lceil \frac{n+1}{2}\right\rceil $
\end_inset

 sites must be sent write lock.
\end_layout

\begin_layout Itemize

\emph on
Read-write conflicts
\emph default
: at least 
\begin_inset Formula $n-k+1$
\end_inset

 sites must be sent a read lock, where 
\begin_inset Formula $k$
\end_inset

 is the number of write locks.
\end_layout

\begin_layout Section
Temporal databses
\end_layout

\begin_layout Paragraph
Temporal dimenstions
\end_layout

\begin_layout Enumerate

\emph on
Valid time
\emph default
: time data valid in Universe of Discourse.
\end_layout

\begin_layout Enumerate

\emph on
Transaction time
\emph default
: time data valid in DBMS.
\end_layout

\begin_layout Paragraph
Modelling a flow of time
\end_layout

\begin_layout Enumerate

\emph on
Discrete
\emph default
 vs 
\emph on
continuous
\emph default
.
\end_layout

\begin_layout Enumerate

\emph on
Unbounded
\emph default
 vs 
\emph on
bounded
\emph default
.
\end_layout

\begin_layout Enumerate

\emph on
Linear
\emph default
 vs 
\emph on
branching
\emph default
.
\end_layout

\begin_layout Paragraph
US-Logic
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until 
\begin_inset Formula $B$
\end_inset

:
\emph default
 
\begin_inset Formula $A$
\end_inset

 holds at every time up to an including the time when 
\begin_inset Formula $B$
\end_inset

 holds.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $A$
\end_inset

 has held at every time since and including the time when 
\begin_inset Formula $B$
\end_inset

 held.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since product 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{S}{\times}B,t\right)=\text{eval}\left(\left(A\times B\right)\cup\left(\left(A\overset{S}{\times}B\right)\ltimes A\right),t-1\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until product 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{U}{\times}B,t\right)=\text{eval}\left(\left(A\times B\right)\cup\left(\left(A\overset{U}{\times}B\right)\ltimes A\right),t+1\right)$
\end_inset

.
\end_layout

\begin_layout Standard
We can derive:
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 since join 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{S}{\bowtie}B,t\right)=\text{eval}\left(\sigma_{A.x=B.x}\left(A\overset{S}{\times}B\right),t\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
\begin_inset Formula $A$
\end_inset

 until join 
\begin_inset Formula $B$
\end_inset


\emph default
: 
\begin_inset Formula $\text{eval}\left(A\overset{U}{\bowtie}B,t\right)=\text{eval}\left(\sigma_{A.x=B.x}\left(A\overset{U}{\times}B\right),t\right)$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Circle A\equiv A\text{ Until }\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at the next time.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\CIRCLE A\equiv A\text{ Since }\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at the previous time.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\lozenge A\equiv\top\text{ Until }A$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at some time in the future.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\blacklozenge A\equiv\top\text{ Since }B$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is true at some time in the past.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\square A\equiv A\text{ Until }\lnot\Circle\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is always true in the future.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\blacksquare A\equiv A\text{ Since }\lnot\CIRCLE\top$
\end_inset

: 
\begin_inset Formula $A$
\end_inset

 is always true in the past.
\end_layout

\end_body
\end_document
