#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO339 Performance Engineering
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard

\emph on
Perfomance engineering
\emph default
: Techniques applied to ensure the 
\series bold
non-functional requirements
\series default
 for perfomance.
 The key is defining a metric (Throughput, energy usage, etc.) and a threshold
 (target / budget).
 miuspe ale hting is no
\end_layout

\begin_layout Paragraph
Defining a target
\end_layout

\begin_layout Itemize

\series bold
Requirements
\series default
:
\series bold
 
\series default
Specific (numeric terms), Measurable, Acceptable (garantee success), Realisable,
 Thorough (covers everything)
\end_layout

\begin_layout Itemize

\series bold
Quality of Service (QoS)
\series default
: Value of a metric that must hold under certain assumptions / conditions.
 Can conflict with functional requirements.
\end_layout

\begin_layout Itemize

\series bold
Service Level Agreement (SLAs)
\series default
: Legal contracts specifying QoS objectives and penalties for violation.
 Enforced by constant monitoring (but not 
\emph on
continuous
\emph default
 â€“ cost)
\end_layout

\begin_layout Paragraph
Performance Evaluation techniques
\end_layout

\begin_layout Itemize

\series bold
Measuring
\series default
: Performed on prototype / final system.
 Good accuracy, often based on instrumentation.
 Costly and difficult to perform.
\end_layout

\begin_layout Itemize

\series bold
Benchmark
\series default
: Apply workload after getting system into a predefined state.
 Workload generator has to be at least as good as the system being benchmarked.
 Types of workloads:
\end_layout

\begin_deeper
\begin_layout Itemize
Batch (like a query set).
 Analyse 
\series bold
throughput
\series default
.
\end_layout

\begin_layout Itemize
Interactive (generate random queries).
 Analyse 
\series bold
latency
\series default
.
\end_layout

\begin_layout Itemize
Hybrids (random access in query set).
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Parameters
\series default
: 
\emph on
System parameters
\emph default
 (caches, CPU instruction costs, etc.).
 
\emph on
Workload parameters
\emph default
 (users, available memory, etc.), often continuous.
\end_layout

\begin_layout Itemize

\series bold
Statistic
\series default
: Aggregate multiple runs with variance to eliminate the noise.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Utilisation
\series default
: % of resource that is used to perform this service
\end_layout

\begin_layout Itemize

\series bold
Bottleneck
\series default
: The resource with the highest utilisation
\end_layout

\end_deeper
\begin_layout Paragraph
Improving performance
\end_layout

\begin_layout Itemize

\series bold
Goal
\series default
: Alternative designs (
\emph on
development
\emph default
) select best value for parameter (
\emph on
tuning
\emph default
).
\end_layout

\begin_layout Itemize

\series bold
Analytical modeling
\series default
: Mathematical relationship between performance parameters and performance
 metrics.
 
\emph on
How to model dynamic system with static equations?
\emph default
 Fast, allow what-if analysis.
\end_layout

\begin_layout Itemize

\series bold
Simulation
\series default
: When system is too complex to be understood.
 Slow experiments.
\end_layout

\begin_layout Paragraph
Parameter tuning
\series medium
.
 Find optimal parameter vector to maximise performance metric & minimise
 the resource consumption.
 Sometimes means trading the use of expensive / non-scalable resource by
 using more of others.
\end_layout

\begin_layout Section
Performance profiling & tracing
\end_layout

\begin_layout Standard

\emph on
Profile
\emph default
: A graphical or other reprentation charactising the system in terms of
 the time it spends in certain states.
 Can be used to identify critical paths, bottlenecks or help tuning.
\end_layout

\begin_layout Paragraph
Events
\series medium
.
 A change in the system.
 Simple (clock tick), complex (cache miss).
 
\end_layout

\begin_layout Itemize

\series bold
Collecting events
\series default
.
 
\series bold
Tracing
\series default
 (keep state for every event, high overhead, more information), 
\series bold
Sampling
\series default
 (keep state in intervals, often time based, inaccurate).
 Sampling with size 1 is event based (counting number of occurences).
\end_layout

\begin_layout Itemize

\series bold
Making a profile
\series default
: Aggregating over the events of a specific metric/
\end_layout

\begin_layout Itemize

\series bold
Trace
\series default
: Ordered log of every state.
 Example with stack call tracing, aggregated in flame graph.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/event-classification.png
	width 90page%

\end_inset


\end_layout

\begin_layout Paragraph
Collecting events
\series medium
.
 Want detailed and accurate measurements whilst limiting the perturbation
 in the system.
 Could collect with software (OS, compiler), hardware (counter) or creating
 an emulator.
\end_layout

\begin_layout Itemize

\series bold
Instrumentation
\series default
: Augment program with even logging code.
 No need for hardware supports and works regardless of admin right etc.
 Overhead and perturbation are high.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Automatic
\series default
 source level: libraries.
 Binary level: Usually compiler supported, less control.
 If static then always pay overhead whereas dynamic means no recompilation,
 can be performed on running process, JIT?
\end_layout

\begin_layout Itemize

\series bold
Manual
\series default
: Logging.
 +: Control, no special hardware or compiler needs.
 -: disabled for release builds, needs recompilation.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Performance counting
\series default
.
 Software (application specific/OS level -packets, context switch).
 Hardware (Often buggy and poorly documented).
\end_layout

\begin_layout Paragraph
CPU architecture
\end_layout

\begin_layout Itemize
Hardware are designed for certain classes of programs and full of hacks
 so optimisation isn't as easy as just making programs with less instructions
 and instead we have a 400 pages long Intel architectures optimisation ref
 manual.
\end_layout

\begin_layout Itemize

\series bold
Pipelining
\series default
: instructions on different stages are executed in parallel on the CPU.
 A 
\series bold
Control hazard
\series default
 means the pipeline is stopped because next intruction is conditional.
\end_layout

\begin_layout Itemize

\series bold
Caches
\series default
: 
\begin_inset Quotes eld
\end_inset

Hot
\begin_inset Quotes erd
\end_inset

 non-programmable memory.
 Organised in a hierarchy of increasing size.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/cache-locality.png
	width 43page%

\end_inset


\begin_inset Graphics
	filename img/hot-dataset.png
	width 43page%

\end_inset


\end_layout

\begin_layout Paragraph
Bottleneck analysis on CPU.
 
\series medium
Consists of checking micro-ops status.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/cpu-bottleneck-analysis.png
	width 50page%

\end_inset


\end_layout

\begin_layout Section
Applied performance modeling
\end_layout

\begin_layout Paragraph
System modeling.

\series medium
 Encompases 
\emph on
hardware
\emph default
, 
\emph on
code
\emph default
, 
\emph on
data
\emph default
/
\emph on
input
\emph default
 to get profile.
\end_layout

\begin_layout Itemize

\series bold
Numerical/experimental models
\series default
: Easy to get if system exists.
 Provides limited insights (not instructive nor interpretable outside of
 the context and so generalises poorly) and requires lots of experimental
 data.
\end_layout

\begin_layout Itemize

\series bold
Analytical models
\series default
: System doesn't need to exist, what-if analysis.
 It requires extensive validation and grows very complex to handle edge
 cases.
\end_layout

\begin_layout Paragraph
System parameters
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a General Purpose Register of the CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the Level 1 Cache (with processing time)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of a General Purpose Register of the CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a cache line of the Level 1 cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the Level 2 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of the Level 1 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a cache line of the Level 2 cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the main memory
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of the Level 2 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a Memory Page
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lookup time in the Page Table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of Memory Pages in the TLB times Page size
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Static analysis
\series default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

extern int* input; extern size_t N; extern size_t stride;
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for (size_t i = 0; i < N; i+= stride) {
\end_layout

\begin_layout Plain Layout

	sum += input[stride];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Formula $s=\text{{stride}}$
\end_inset

, 
\begin_inset Formula $T_{mem}=\sum_{i=0}^{3}I_{i}\times\min(1,\frac{{s}}{B_{i}})$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Dynamic systems and state
\series default
.
 Stochastical models, in particular markov chains.
\end_layout

\begin_layout Paragraph
Modeling memory access
\end_layout

\begin_layout Itemize

\series bold
Parameters
\series default
: 
\begin_inset Formula $R_{n}$
\end_inset

 number of stored tuples, 
\begin_inset Formula $R_{w}$
\end_inset

(size of tuple in words).
 
\begin_inset Formula $||R||$
\end_inset

 (size of region) is product of length and width.
 
\begin_inset Formula $u$
\end_inset

 is number of word read in each access.
\end_layout

\begin_layout Itemize

\series bold
Composition
\series default
: 
\begin_inset Formula $P_{1}\oplus P_{2}$
\end_inset

 Serial execution of 
\begin_inset Formula $P_{1}$
\end_inset

,
\begin_inset Formula $P_{2}$
\end_inset

.
 
\begin_inset Formula $P_{1}\odot P_{2}$
\end_inset

 concurrent execution.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// uniform random data, 1024 values
\end_layout

\begin_layout Plain Layout

extern struct{int a; int b; int c;}* input1;
\end_layout

\begin_layout Plain Layout

extern int* input2; // random data, 64 values
\end_layout

\begin_layout Plain Layout

int sum = 0; for(size_t i = 0; i < inputSize; i++) {
\end_layout

\begin_layout Plain Layout

	sum += input2[input1[i].a] >> 4;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\text{{s\_trav}(R.w = 3, u =1, R.n=1024)\odot\text{{rr\_acc}(R.w=1, u=1, R.n=64, r=1024)}}$
\end_inset


\end_layout

\begin_layout Paragraph
Assumptions
\series medium
.
 Assume distribution and independence of the input.
 Assume independent parallelism (cache contention etc.
 not discussed).
 Can't model noise.
\end_layout

\begin_layout Section
CPU efficient code
\end_layout

\begin_layout Paragraph
Metrics
\end_layout

\begin_layout Itemize

\series bold
Wall time
\series default
 is ultimate goal when Cycles Per Instructions is more of a parameter.
\end_layout

\begin_layout Itemize

\series bold
Stall cycles
\series default
 can be good but can miss the bigger picture, but help reduce:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Control
\emph default
 hazards: stalls due to data-dependent flow
\end_layout

\begin_layout Itemize

\emph on
Structural
\emph default
 hazards: stalls due to CPU's features
\end_layout

\begin_layout Itemize

\emph on
Data
\emph default
 hazards: stalls due to operands not being there on time.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
CPU efficiency
\series default
: proxy metrics
\end_layout

\begin_deeper
\begin_layout Itemize
Work-efficiency: Don't waste cycles
\end_layout

\begin_layout Itemize
Simplicity: Fewer instructions for less resource utilisation
\end_layout

\begin_layout Itemize
Parallelism: even in non parallel algorithms
\end_layout

\begin_layout Itemize
Predictability: ease speculation
\end_layout

\begin_layout Itemize
Adaptivity: acount for unknown parameters
\end_layout

\begin_layout Itemize
Specialization: use of hardware features
\end_layout

\begin_layout Itemize
Separation of Concerns: make hardware do heavy lifting
\end_layout

\end_deeper
\begin_layout Paragraph
Design decisions
\series medium
: Know the system's specifications, can it do out-of order / speculative
 execution? 
\emph on
Dynamic
\emph default
 parallelism (superscalar execution) or 
\emph on
statically
\emph default
 bundled (SIMD or Very long instruction word - VLIW)?
\end_layout

\begin_layout Paragraph
More architecture
\end_layout

\begin_layout Itemize

\series bold
Pipeline execution
\series default
: 
\begin_inset Formula $\neq$
\end_inset

instruction in 
\begin_inset Formula $\neq$
\end_inset

stages.
 Affected by
\emph on
 all 3
\emph default
 hazards
\end_layout

\begin_layout Itemize

\series bold
Superscalar execution
\series default
: 
\begin_inset Formula $\neq$
\end_inset

 instructions in same stage.
\end_layout

\begin_layout Itemize

\series bold
Out of order
\series default
: Exploits expression reordering and better ALU allocation.
 Suffers from 
\emph on
control
\emph default
 hazards.
\end_layout

\begin_layout Itemize

\series bold
Speculative execution
\series default
: Fills pipeline if no instruction is eligible.
 Addresses 
\emph on
control
\emph default
 hazard.
\end_layout

\begin_layout Itemize

\series bold
SIMD
\series default
: Vector registers can perform operation on set of values faster than one
 by one.
 Careful about clocking down CPU during that time though.
\end_layout

\begin_layout Itemize

\series bold
VLIW
\series default
: Instruction encoding multiple regular instructions.
\end_layout

\begin_layout Paragraph
Partial evaluation
\end_layout

\begin_layout Itemize

\series bold
Constant evaluation
\series default
: When scope allows it.
\end_layout

\begin_layout Itemize

\series bold
Lifting / eliminating expensive operations
\series default
: Don't do it by writting code for each cases, let the compiler do it (template
 meta-programming).
\end_layout

\begin_layout Itemize

\series bold
JIT compilation, inlining, symbolic programming.
\end_layout

\begin_layout Paragraph
Predicability
\series medium
.
 Very data dependent but code can be quite predicatable.
 Use 
\emph on
predication
\emph default
/if-conversion if measure indicates otherwise.
\end_layout

\begin_layout Paragraph
CPU in-core parallelism, do it in hardware.

\series medium
 Compilers try to auto-vectorise, if fail use Intel intrinsics (functions
 mapped to assembly).
\end_layout

\begin_layout Section
Memory efficient code
\end_layout

\begin_layout Paragraph
Data hazards
\end_layout

\begin_layout Itemize

\series bold
Cache misses
\series default
, the three Cs (plus 
\emph on
coherence
\emph default
 across cores)
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Compulsory
\emph default
: first access of the cache line
\end_layout

\begin_layout Itemize

\emph on
Capacity
\emph default
: Discarded value and retrived later
\end_layout

\begin_layout Itemize

\emph on
Conflict
\emph default
: Direct map and set-associative block-placement strategy
\end_layout

\end_deeper
\begin_layout Paragraph
Causes for data stalls (type) and solutions:
\end_layout

\begin_layout Itemize
Non compulsory 
\emph on
cache miss
\emph default
 (
\series bold
capacity bound
\series default
): Reduce hot dataset size
\end_layout

\begin_deeper
\begin_layout Itemize
Popular cache replacement strategy is 
\series bold
LRU
\series default

\begin_inset Formula $\rightarrow$
\end_inset

can cause 
\series bold
thrashing
\end_layout

\begin_layout Itemize

\series bold
Tile loops
\series default
 to decrease hot dataset size.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Fully utilised memory bus
\emph default
 (
\series bold
bandwidth bound
\series default
): Increase cache-line utilisation
\end_layout

\begin_layout Itemize
Otherwise compulsory misses (
\series bold
latency bound
\series default
): Prefetch
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{void 
\backslash
_
\backslash
_buildin
\backslash
_prefetch(const void *addr, $...$);}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Virtual memory (hardware optimise to reduce latency)
\end_layout

\begin_layout Itemize

\series bold
Address translation
\series default
: CPU deals in virtual addresses.
 Addresses in cache are 
\emph on
virtually indexed
\emph default
 and 
\emph on
physically tagged
\emph default
 (VIPT).
 Translation Lookaside Buffer (
\emph on
TLB
\emph default
) caches translations, page fault is interupt.
\end_layout

\begin_layout Itemize

\series bold
Memory allocation
\series medium
.
 Difference between once, eager, and lazy (reallocation) is caused by 
\series bold
Copy on Write
\series medium
.
\end_layout

\begin_layout Itemize
What happens when a prefetch causes a TLB miss (
\series bold
page fault
\series default
) ? Fetching page should cause OS interupt (resolve synonyms by page colouring,
 set up CoW etc.) so shouldn't prefetch.
\end_layout

\begin_layout Paragraph*
Multicore effect and coherance.

\series medium
 
\emph on
MESI
\emph default
 to coordinate caches in QPI (Intel quickpath interconnect).
 Cache lines can cause false sharing (writing to same line but different
 addresses), slowdown of 
\begin_inset Formula $\approx0.85T$
\end_inset

x where 
\begin_inset Formula $T$
\end_inset

 is number of cores.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/mesi.png
	width 45page%

\end_inset


\begin_inset Graphics
	filename img/false-sharing.png
	width 45line%

\end_inset


\end_layout

\begin_layout Section
Load Testing
\end_layout

\begin_layout Paragraph
Benchmarks v.
 micro-benchmarks
\end_layout

\begin_layout Itemize
Benchmarks are complex tests against a 
\emph on
reference
\emph default
 workload (
\series bold
realistic
\series default
).
 Assess business purposes, highlights hardware limitations, and certify
 performance.
\end_layout

\begin_layout Itemize
Micro-benchmarks are 
\series bold
short
\series default
 tests designed to help optimise a critical part.
\end_layout

\begin_layout Paragraph
Standart industry benchmarks
\series medium
.
 From non-profits (TPC, SPEC).
 Should be 
\series default
repeatable
\series medium
, 
\series default
interpretable
\series medium
, 
\series default
comparable
\series medium
, 
\series default
vendor-neural
\series medium
, 
\series default
transparent
\series medium
 and well documented.
 Examples include:
\end_layout

\begin_layout Itemize
SPEC: CPU2006 (integer and floating-point ops), jbb2015 (multitier Java
 app), Cloud_IaaS (Map reduce, cassandra), etc.
\end_layout

\begin_layout Itemize
TPC: -C (database transactions), -H (analytical queries), -DS (Big data
 â€“ Hadoop/Spark), etc.
\end_layout

\begin_layout Paragraph
Specjbb2015
\series medium
.
 Evaluates performance and scalability of 
\emph on
environments
\emph default
 for Java business applications (here a fake supermaket).
 In addition to the fake app, includes a simulator that will scale the workload
 injection, and a monitor to generate reports with key metrics.
 It is made of three parts the backend (fake app), the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{TxInjector}
\end_layout

\end_inset

s and one Controller to coordinate the first two.
\end_layout

\begin_layout Itemize

\series bold
Controller
\series default
: Synchronise start/stop of the load injectors, coordinates benchmarking
 phases, 
\series bold
dispaches work to load injectors
\series default
, send heartbeats to 
\series bold
detect failure
\series default
 and recover, collects aggregates and 
\series bold
stores the test results
\series default
.
 Also configures the backend agents that manage the fake application.
\end_layout

\begin_layout Itemize

\series bold
Load injectors
\series default
: Each controls a 
\series bold
thread pool
\series default
 where each thread issues requests and waits for replies.
 Threads are separated by 
\series bold
think time
\series default
 before being issued.
 Uses java 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
texttt{nio}
\end_layout

\end_inset

 for concurrent I/O.
 
\series bold
Report results
\series default
 to coordinator.
 
\end_layout

\begin_layout Itemize

\series bold
Execution phases
\series default
: Search High Bound Injection Rate (
\emph on
HBIR
\emph default
) 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 Response Troughput (
\emph on
RT
\emph default
) curve building 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 Validation 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 Profiling (statistical data) 
\begin_inset ERT
status open

\begin_layout Plain Layout

$
\backslash
rightarrow$
\end_layout

\end_inset

 Reporter (.html).
 During 
\emph on
RT
\emph default
 curve building, observe transient and steady phases.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/rt-specjbb.png
	width 80line%

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Reported metrics
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
max-jOPS
\emph default
: maximum sustainable injection rate, above which the system does not convergenc
e to steady-state within 90s
\end_layout

\begin_layout Itemize

\emph on
critical-jOPS
\emph default
: mean of injection rates of first failure and of last success of SLA (99th
 percentile on response time)
\end_layout

\end_deeper
\begin_layout Paragraph
Load testing
\series medium
.

\series default
 Limitations of benchmarks 
\series medium
above: we only tested the platform, it's only a metric to evaluate JBA providers.
 Creating a test workload for an arbitrary application can be done by either
 customising benchmark or using a customable testing tool (JMeter, Selenium,
 etc.) and do load testing which allows to simulate load (injectors, browsers)
 and emulate realistic / custom user behaviors (think times, abandonment,
 resume sessions, mix of requests, etc.).
\end_layout

\begin_layout Section
User behavior modelling
\end_layout

\begin_layout Paragraph
Log file.

\series medium
 Use tools to automate collection (elasticsearch, Logstash).
 In distributed systems, logs need to be combined into 
\series default
workload traces
\series medium
 which organises events that pertain to arrival and service of requests
 in a 
\series default
time series
\series medium
.
 We use those to understand, simulate (what-if) and replay a sequences of
 events.
\end_layout

\begin_layout Paragraph
Common issues in workload traces
\series medium
 include 
\emph on
privacy
\emph default
, 
\emph on
inflexibility
\emph default
 (analyse effect of specific parameters), 
\emph on
noise
\emph default
 and 
\emph on
overfitting
\emph default
 the 
\series default
workload models
\series medium
 (model to reproduce a trace) we create to the data using 
\emph on
Workload characterization
\emph default
 (model parameters are fitted to traces to capture their essential characteristi
cs).
 We want models to be able to repeat a trace (although non-identically),
 give us an understanding of the system and, over traces, they present the
 advantage of always being available (no sysadmin / privacy issues).
\end_layout

\begin_layout Paragraph*
User behaviour graph (UBG)
\series medium
.
 Discrete time Markov chains where states are pages / sessions or a service
 invocation.
 We use user sessions (the sequence of states a particular user invokes)
 to determine the transition probabilities.
 A good fingerprinting of users is essential in web applications to take
 care of problems like users using multiple browsers, sharing the same IP
 or later resume of session.
 We use them to perform 
\emph on
simulation
\emph default
, 
\emph on
analysis
\emph default
 of UB, investigate consequences of 
\emph on
modification
\emph default
 and perform 
\emph on
clustering
\emph default
 for business analystics.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
p_{ij}=\frac{\text{{number\,of\,requests\,for\,}j \text{{with\,}i \text{as a referer URL}} }}{\sum_{k\in S}\text{number of requests for }k\text{ with }i\text{ as a referer URL}}
\]

\end_inset


\end_layout

\begin_layout Paragraph
Properties of UBGs
\end_layout

\begin_layout Itemize

\series bold
Visit ratio
\series default
: Average number of visits 
\begin_inset Formula $V(i)$
\end_inset

 to state 
\begin_inset Formula $i$
\end_inset

.
 With 
\emph on

\begin_inset Formula $E$
\end_inset


\emph default
 the entry state (
\begin_inset Formula $V(E)=1$
\end_inset

).
\begin_inset Formula 
\[
V(j)=\sum_{i\in S}V(i)p_{ij}\;\;\forall j\in S\backslash\{E\}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Session length
\series default
: Average session length for a user, with 
\begin_inset Formula $X$
\end_inset

 the exit state.
\begin_inset Formula 
\[
L=\sum_{i\in S\backslash\{E,X\}}V(i)
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Distribution of states
\series default
: 
\begin_inset Formula $\pi^{(n)}(i)$
\end_inset

: probability of being in state 
\begin_inset Formula $i$
\end_inset

 at the 
\begin_inset Formula $n$
\end_inset

th invocation (how often user reaches 
\begin_inset Formula $i$
\end_inset

 after 
\begin_inset Formula $n$
\end_inset

 visits.
 
\begin_inset Formula 
\[
\pi^{(n)}=[\pi_{i}^{(n)}|i\in S]\,\,\text{(State probability vector)}
\]

\end_inset


\begin_inset Formula 
\[
\pi^{(0)}=[\pi_{E}^{(0)},\pi_{H}^{(0)},\dots,\pi_{X}^{(0)}]=[1,0,\dots,0]
\]

\end_inset


\begin_inset Formula 
\[
\pi_{j}^{(n)}=\sum_{i\in S}\pi_{i}^{(n-1)}p_{ij},\,j\in S\,\equiv\pi^{(n)}=\pi^{(n-1)}P\Rightarrow\pi^{(n)}=\pi^{(0)}P^{n}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Session length distribution: 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\pi_{X}^{(n)}$
\end_inset

 probability of leaving the system in 
\begin_inset Formula $n$
\end_inset

 page visits or less.
\end_layout

\begin_layout Itemize
\begin_inset Formula $\Rightarrow\pi_{X}^{(n)}-\pi_{X}^{(n-1)}$
\end_inset

is the probability of completing the session after exactly 
\begin_inset Formula $n$
\end_inset

 page requests
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename img/session-length-distribution.png
	width 98line%

\end_inset


\end_layout

\begin_layout Paragraph
Fitting UBGs from log data
\end_layout

\begin_layout Itemize
Define for user 
\begin_inset Formula $u$
\end_inset

 the matrix 
\begin_inset Formula $C_{u}$
\end_inset

with entry 
\begin_inset Formula $(i,j)$
\end_inset

 conts visits to page 
\begin_inset Formula $j$
\end_inset

 after visiting 
\begin_inset Formula $i$
\end_inset

.
 Normalise the rows to sum to one to turn into UBG.
 For 
\begin_inset Formula $n$
\end_inset

 pages 
\begin_inset Formula $C_{u}$
\end_inset

maps to 
\series bold
Euclidean space
\series default
 with 
\begin_inset Formula $n^{2}$
\end_inset

dimensions.
\end_layout

\begin_layout Itemize
Use 
\series bold

\begin_inset Formula $k$
\end_inset

-means clustering
\series default
 to find clusters equivalent to classes user in this space.
\end_layout

\begin_deeper
\begin_layout Itemize
Input: Points in space, number of clusters 
\begin_inset Formula $k$
\end_inset


\end_layout

\begin_layout Itemize
Output: coordinates of 
\begin_inset Formula $k$
\end_inset

 centroids.
\end_layout

\begin_layout Itemize
Initialise centroid positions randomly, repeat until convergence the following:
 for every point 
\series bold
assign to the cluster with nearest centroid
\series default
 and for every cluster, 
\series bold
recalculate the positions of the centroids
\series default
.
\end_layout

\begin_layout Itemize
Nearest is as Euclidean distance: 
\begin_inset Formula 
\[
d(C_{u},C_{v})=\sqrt{\sum_{i=1}^{n}\sum_{j=1}^{n}(C_{u}(i,j)-C_{v}(i,j))^{2}}
\]

\end_inset


\end_layout

\begin_layout Itemize
Centroid position is average coordinates of the points in cluster
\begin_inset Formula 
\[
c(i,j)=\frac{1}{n_{c}}\sum_{u\in\text{cluster}}C_{u}(i,j)
\]

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Limitation of UBGs
\series medium
 includes that they 
\series default
don't include content
\series medium
 inside the states (what got searched), 
\series default
don't include resource usage
\series medium
 and may 
\series default
create invalid path 
\series medium
(no login for example).
 Extensions will include creating user classes, conditional actions, data
 flows, etc.
 and are used in tools.
\end_layout

\begin_layout Section
Bottlenecks in distributed systems
\end_layout

\begin_layout Standard
Answering questions about 
\series bold
which resource limits the scalibility
\series default
 of the application, perform what-if analysis (how will changes in user
 requests rates or resource speed impact performance, etc.).
 
\series bold
Individual resources are affected by system metrics
\series default
 (arrival rate, service time, contention).
 We want to highlight those correlations, and focus on resources being 
\series bold
busy
\series default
 (at server/tier level or hardware component level) and not so much model
 
\emph on
contention
\emph default
.
\end_layout

\begin_layout Paragraph
Service classes
\end_layout

\begin_layout Itemize
System offers 
\begin_inset Formula $C$
\end_inset

 types of services (
\series bold
service class
\series default
) using 
\begin_inset Formula $M$
\end_inset

 resources (like web pages using a web server and a database).
\end_layout

\begin_layout Itemize

\series bold
Demand
\series default
: 
\begin_inset Formula $D_{ic}=k_{ic}S_{ic}$
\end_inset

 is service time accumulated by class-
\begin_inset Formula $c$
\end_inset

 request through its visits to resource 
\begin_inset Formula $i$
\end_inset

.
 On contention/queuing demand is only the effective processing time, not
 other overheads.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $k_{ic}$
\end_inset

is average number of calls to resource 
\begin_inset Formula $i$
\end_inset

 for class-
\begin_inset Formula $c$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $S_{ic}$
\end_inset

is mean service time for class-
\begin_inset Formula $c$
\end_inset

 on resource 
\begin_inset Formula $i$
\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Operational analysis
\end_layout

\begin_layout Itemize

\series bold
Common metrics: 
\series default

\begin_inset Formula $A_{c}$
\end_inset

: total number of arriced requests of class 
\begin_inset Formula $c$
\end_inset

.
 
\begin_inset Formula $B_{ic}$
\end_inset

: total time resource 
\begin_inset Formula $i$
\end_inset

 is busy because of class-
\begin_inset Formula $c$
\end_inset

 request
\end_layout

\begin_layout Itemize
Given the 
\series bold
oservation period
\series default
 
\begin_inset Formula $T$
\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\lambda_{c}=A_{c}/T$
\end_inset

: 
\series bold
average arrival rate
\series default
 of class-
\begin_inset Formula $c$
\end_inset

 requests
\end_layout

\begin_layout Itemize
\begin_inset Formula $U_{ic}=B_{ic}/T$
\end_inset

: 
\series bold
utilisation
\series default
 of resource 
\begin_inset Formula $i$
\end_inset

 due to class-
\begin_inset Formula $c$
\end_inset

 request
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Stable system throughput
\series default
: if requests never fail and pending requests are always bounded then 
\begin_inset Formula $\lambda_{c}$
\end_inset

equals class-
\begin_inset Formula $c$
\end_inset

 
\series bold
throughput 
\begin_inset Formula $X_{c}$
\end_inset


\series default
 as 
\begin_inset Formula $T$
\end_inset

 grows large.
 An 
\series bold
unstable
\series default
 system cannot cope with arrival rate so 
\begin_inset Formula $\lim_{T\rightarrow\infty}\text{pending}(c)\not\rightarrow0$
\end_inset

.
\begin_inset Formula 
\[
\lambda_{c}=\lim_{T\rightarrow\infty}\frac{A_{c}}{T}=\lim_{T\rightarrow\infty}\frac{\text{completed}(c)+\text{pending}(c)}{T}=\lim_{T\rightarrow\infty}\frac{\text{completed}(c)}{T}=X_{c}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/example-metrics-calculation.png
	width 75line%

\end_inset


\end_layout

\begin_layout Paragraph
Utilisation law
\end_layout

\begin_layout Itemize
\begin_inset Formula $D_{ic}=B_{ic}/A_{c}$
\end_inset

 since 
\begin_inset Formula $B_{ic}/A_{c}$
\end_inset

 averages the total processing time of class-
\begin_inset Formula $c$
\end_inset

 requestions at resource 
\begin_inset Formula $i$
\end_inset

 (by definition 
\begin_inset Formula $D_{ic}$
\end_inset

)
\end_layout

\begin_layout Itemize
Relationship between utilisation and demand:
\begin_inset Formula 
\[
U_{ic}=\frac{B_{ic}}{T}=\frac{A_{c}}{T}\frac{B_{ic}}{A_{c}}=\lambda_{c}D_{ic}
\]

\end_inset


\end_layout

\begin_layout Itemize
For a system with 
\begin_inset Formula $C$
\end_inset

 workload classes, total resource utilisation 
\begin_inset Formula $U_{i}$
\end_inset

 is:
\begin_inset Formula 
\[
U_{i}=\sum_{c=1}^{C}U_{ic}=\sum_{c=1}^{C}\lambda_{c}D_{ic}=\sum_{c=1}^{C}X_{c}D_{ic}
\]

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Example:
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/example-utilisation-ubg.png
	width 98line%

\end_inset


\end_layout

\begin_layout Paragraph
Demand estimation from utilisation samples
\series medium
.
 Utilisation law describes a hyperplane with slopes 
\begin_inset Formula $D_{ic}$
\end_inset

.
 
\series default
Multivariate linear regression
\series medium
 fits hyperplane to sample of 
\begin_inset Formula $U_{i}$
\end_inset

 and 
\begin_inset Formula $\lambda_{c}$
\end_inset

 (or 
\begin_inset Formula $X_{c}$
\end_inset

), 
\begin_inset Formula $\forall c$
\end_inset

 returning the demands 
\begin_inset Formula $D_{ic}$
\end_inset

.
 The estimated demands are hardware dependent and will change after hardware
 upgrades.
\end_layout

\begin_layout Paragraph
Bottleneck analysis
\series medium
.
 Determine the resource that limits scalability.
\end_layout

\begin_layout Itemize
Bottlenecks are 
\series bold
oversubsribed resources
\series default
 which struggle to complete backlog of pending requests.
 Often run near 100% utilisation (
\series bold
saturation
\series default
).
 Analysis answers:
\end_layout

\begin_deeper
\begin_layout Itemize
As we increase the arrival rates of requests, which resource(s) will saturate
 first?
\end_layout

\begin_layout Itemize
What is the 
\series bold
maximum arrival rate
\series default
 that the system can sustain under a given request mix?
\end_layout

\end_deeper
\begin_layout Itemize
In system with 
\begin_inset Formula $M$
\end_inset

 resources we can describe resource usage as the following system of linear
 equations, where we require 
\begin_inset Formula $U_{i}\leq1\,\forall i$
\end_inset

 :
\begin_inset Formula 
\[
U_{i}=\sum_{c=1}^{C}\lambda_{c}D_{ic},\,\,i=1,\dots,M
\]

\end_inset


\end_layout

\begin_layout Itemize
Resource 
\begin_inset Formula $j$
\end_inset

 can saturate 
\begin_inset Formula $\iff\exists(\lambda_{1},\dots,\lambda_{C})$
\end_inset

 such that 
\begin_inset Formula $U_{j}=1$
\end_inset


\end_layout

\begin_layout Itemize
Therefore it's possible to build the following 
\series bold
LP
\series default
 where optimal value over variables 
\begin_inset Formula $\lambda_{c}$
\end_inset

 where if the optimal value 
\begin_inset Formula $U_{j}^{\text{max}}=1$
\end_inset

 then 
\begin_inset Formula $j$
\end_inset

 can saturate.
\begin_inset Formula 
\begin{alignat*}{2}
U_{i} & =\text{maximise} & \sum_{c=1}^{C}\lambda_{c}D_{jc}\\
 & \text{subject to} & \sum_{c=1}^{C}\lambda_{c}D_{ic}\leq1,\, & i=1,\dots,M\\
 &  & \lambda_{c}\geq0,\, & c=1,\dots,M
\end{alignat*}

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Example
\series default
: Assume 
\begin_inset Formula $C=2$
\end_inset

 workload classes and 
\begin_inset Formula $M=4$
\end_inset

 resources.
 Each line represents boundary of 
\begin_inset Formula $U_{i}\leq1$
\end_inset

 for given 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $D_{ic}$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Itemize
Each point 
\begin_inset Formula $(\lambda_{1},\lambda_{2})$
\end_inset

 is a possible arrival rate to the system.
\end_layout

\begin_layout Itemize
The shaded region indicates the sustainable arrival rates.
\end_layout

\begin_layout Itemize
Server 1 can never become a bottleneck.
 Never upgrade it!
\end_layout

\begin_layout Itemize
Server 2 is the 
\series bold
class-1 bottleneck
\series default
 (largest demand in class 1).
\end_layout

\begin_layout Itemize
Server 3 is the 
\series bold
class-2 bottleneck
\series default
 (largest demand in class 2).
\end_layout

\begin_layout Itemize
Server 4 is a 
\series bold
bottleneck only for some arrival rates
\series default
.
 
\end_layout

\begin_layout Itemize
Servers 2,3,4 are thus potential bottlenecks for this system.
\end_layout

\begin_layout Itemize
Some 
\series bold
mixes
\series default
 lead multiple resources to become bottlenecks 
\series bold
simultaneously
\series default
, e.g., 2 + 3 or 2 + 4
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Graphics
	filename img/lp-graph.png
	width 70line%

\end_inset


\end_layout

\begin_layout Paragraph
Bottleneck migration
\series medium
.
 If system has single bottleneck, we can upgrade the hardware / scale up
 VM.
 But arrival rates change over time (day/night, longer periods, etc.) and
 thus actually 
\series default
show different bottlenecks
\series medium
 over time.
 We require 
\series default
adaptive resource management
\series medium
 (e.g.
 in cloud) to cope with transient needs.
\end_layout

\begin_layout Paragraph
Bottleneck switches
\series medium
.
 Multiple pototential bottlenecks, it is possible for them to migrate accross
 resources at the millisecond level (
\series default
millibottlenecks
\series medium
) which can be invisible to monitoring (
\begin_inset Formula $10\text{s}+5\text{ms}\approx10\text{s}$
\end_inset

).
 They downgrade performance by queueing transactions.
 A 
\series default
symptom
\series medium
 is that throughput grows slowly, even if the system is lightly utilised.
\end_layout

\begin_layout Section
Design of experiments
\end_layout

\begin_layout Paragraph
Terminology
\end_layout

\begin_layout Itemize

\series bold
Response variable
\series default
: Measurement of outcome (
\emph on
response time, throughput
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
Factor
\series default
: Option that affects the response variable
\end_layout

\begin_layout Itemize

\series bold
Level
\series default
: Value a factor can take
\end_layout

\begin_layout Itemize

\series bold
Design
\series default
: Plan including the number of experiments and values of levels
\end_layout

\begin_layout Itemize

\series bold
Interaction
\series default
: Two factors interact if their levels 
\series bold
jointly affect the response variable
\series default
.
\end_layout

\begin_layout Paragraph
Blackbox modeling
\series medium
.
 Analytical models are too error-prone as the system's internal complexity
 grows so we build models 
\series default
agnostic
\series medium
 of the internals.
 We also note we cannot change one factor at a time if factors are interacting
 which we generally need to run experiments to first determine.
\end_layout

\begin_layout Paragraph
Screening response models
\series medium
.
 With factors 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, we focus on 
\begin_inset Formula $\epsilon=0$
\end_inset

:
\begin_inset Formula 
\[
y=q_{0}+q_{A}x_{A}+q_{B}x_{B}+q_{AB}x_{A}x_{B}+\epsilon
\]

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $y$
\end_inset

: response variable
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{A},x_{B}$
\end_inset

: levels of factors 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

, 
\begin_inset Formula $x_{AB}$
\end_inset

 interaction of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $q_{0},q_{A},q_{B},q_{AB}$
\end_inset

: 
\series bold
effects
\series default
, coefficients explaining the influence of the factors
\end_layout

\begin_layout Itemize
With 
\begin_inset Formula $k$
\end_inset

 factors, we can scale up:
\begin_inset Formula 
\[
y=q_{0}+\sum_{j}q_{j}x_{j}+\sum_{j,k,j\neq k}q_{jk}x_{j}x_{k}+\sum_{j,k,l,j\neq k\neq l}q_{jkl}x_{j}x_{k}x_{l}+\epsilon
\]

\end_inset


\end_layout

\begin_layout Paragraph
Design methods
\end_layout

\begin_layout Itemize

\series bold
Full factorial design
\series default
: Run every combination and thus indentify most important factors.
 Delivers max information but limited applicability (expensive).
\end_layout

\begin_layout Itemize

\series bold
Fractional factorial design
\series default
: A fraction of the experiments of full factorial, so only captures some
 interactions.
 Finds optimal results if those unstudied interactions are negligeble.
 Very applicable and popular.
\end_layout

\begin_layout Paragraph
\begin_inset Formula $2^{k}$
\end_inset

 factorial design
\series medium
.
 
\begin_inset Formula $k$
\end_inset

 factors, each having 2 levels.
\end_layout

\begin_layout Itemize
\begin_inset Formula $y_{i}$
\end_inset

: response variable in the 
\begin_inset Formula $i$
\end_inset

-th experiment (
\begin_inset Formula $1\leq i\leq2^{k}$
\end_inset

)
\end_layout

\begin_layout Itemize
\begin_inset Formula $x_{f,i}$
\end_inset

: level of factor 
\begin_inset Formula $f$
\end_inset

 in the 
\begin_inset Formula $i$
\end_inset

-th experiment
\end_layout

\begin_layout Paragraph
Example
\series medium
.
 With 
\series default

\begin_inset Formula $x_{A}=-1$
\end_inset


\series medium
 if A = -1, etc.
\end_layout

\begin_layout Itemize
We build the system
\begin_inset Formula 
\begin{align*}
y_{1}= & 15=q_{0}-q_{A}-q_{B}+q_{AB}\\
y_{2}= & 45=q_{0}+q_{A}-q_{B}-q_{AB}\\
y_{3}= & 25=q_{0}-q_{A}+q_{B}-q_{AB}\\
y_{4}= & 75=q_{0}+q_{A}+q_{B}+q_{AB}
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Which is solved as follows
\begin_inset Formula 
\begin{align*}
q_{0}= & (1/4)(y_{1}+y_{2}+y_{3}+y_{4}) & =40\\
q_{A}= & (1/4)(-y_{1}+y_{2}-y_{3}+y_{4}) & =20\\
q_{B}= & (1/4)(-y_{1}-y_{2}+y_{3}+y_{4}) & =10\\
q_{AB}= & (1/4)(y_{1}-y_{2}-y_{3}+y_{4}) & =5
\end{align*}

\end_inset


\end_layout

\begin_layout Itemize
Or more easily using the sign table method:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
75
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y*col/2^{2}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $=q_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $=q_{A}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $=q_{B}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $=q_{AB}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
a
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Interpretation.
 
\series medium

\begin_inset Formula $q_{0}$
\end_inset

 is global average.
 
\begin_inset Formula $q_{A}$
\end_inset

 means A affects the average by 
\begin_inset Formula $\pm q_{A}$
\end_inset

 (
\begin_inset Formula $+q_{A}$
\end_inset

 if A is 1, -1 otherwise) and similar interpretations for 
\begin_inset Formula $q_{B}$
\end_inset

.
 
\begin_inset Formula $q_{AB}$
\end_inset

 (cross average) the interaction affects the average by 
\begin_inset Formula $\pm q_{AB}$
\end_inset

.
\end_layout

\begin_layout Itemize
What does 
\begin_inset Formula $q_{A}=q_{B}=q_{AB}=0$
\end_inset

 means?
\end_layout

\begin_layout Itemize
What does 
\begin_inset Formula $q_{A}=q_{B}=0,\,q_{AB}\neq0$
\end_inset

 means?
\end_layout

\begin_layout Itemize
If 
\begin_inset Formula $q_{B}=q_{AB}=0$
\end_inset

 and fix 
\begin_inset Formula $c\geq0$
\end_inset

 what difference does 
\begin_inset Formula $q_{A}=c$
\end_inset

 or 
\begin_inset Formula $q_{A}=-c$
\end_inset

 have?
\end_layout

\begin_layout Paragraph
Allocation of variation
\series medium
.
 Study of the influence of the factors on the response.
 We will explain the 
\series default
variance
\series medium
 on the 
\begin_inset Formula $y_{i}$
\end_inset

 values.
 We use the 
\emph on
Sum of Squares Total
\emph default
 (SST), a scaled variance to study impact of factors.
 We note that 
\begin_inset Formula $\bar{y}=q_{0}$
\end_inset

.
\end_layout

\begin_layout Standard

\series medium
\begin_inset Formula 
\begin{align*}
\text{SST}= & \sum_{1\leq i\leq2^{k}}(y_{i}-\bar{y})^{2}\\
= & \sum_{1\leq i\leq2^{k}}(q_{A}x_{A,i}+q_{B}x_{B,i}+q_{AB}x_{A,i}x_{B,i})^{2}\\
= & \sum_{1\leq i\leq2^{k}}(q_{A}x_{A,i})^{2}+\sum_{1\leq i\leq2^{k}}(q_{B}x_{B,i})^{2}\\
 & +\sum_{1\leq i\leq2^{k}}(q_{AB}x_{A,i}x_{B,i})^{2}+\text{product terms}
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Now using the fact that 
\begin_inset Formula $x_{A,i}^{2}=x_{B,i}^{2}=1$
\end_inset

, the fact that the 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 column in the sign table sum to 0 (
\begin_inset Formula $\sum_{1\leq i\leq2^{k}}x_{A,i}=\sum_{1\leq i\leq2^{k}}x_{B,i}=0$
\end_inset

 and by orthogonality of the sign table (
\begin_inset Formula $\sum_{1\leq i\leq2^{k}}x_{A,i}x_{B,i}=0)$
\end_inset

 we get that the product terms simplify to zero.
\begin_inset Formula 
\[
\Rightarrow\text{SST}=q_{A}^{2}\sum_{1\leq i\leq2^{k}}x_{A,i}^{2}+q_{B}^{2}\sum_{1\leq i\leq2^{k}}x_{B,i}^{2}+q_{AB}^{2}\sum_{1\leq i\leq2^{k}}(x_{A,i}x_{B,i})^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
And due to the squaring, the sums are equivalent to 
\begin_inset Formula $\sum_{1\leq i\leq2^{k}}1=2^{k}$
\end_inset

.
 With 
\begin_inset Formula $k=2$
\end_inset

:
\begin_inset Formula 
\[
\text{SST}=4(q_{A}^{2}+q_{B}^{2}+q_{AB}^{2})
\]

\end_inset


\end_layout

\begin_layout Standard
We can build 
\begin_inset Formula $\text{SSA}=4q_{A}^{2},\,\text{SSB}=4q_{B}^{2},\,\text{SSAB}=4q_{AB}^{2}$
\end_inset

 the variation explained by 
\begin_inset Formula $A$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $AB$
\end_inset

 respectively.
 And the ratios 
\begin_inset Formula $\text{SSA}/\text{SST}$
\end_inset

,
\begin_inset Formula $\text{SSB}/\text{SST}$
\end_inset

,
\begin_inset Formula $\text{SSAB}/\text{SST}$
\end_inset

 show the percentage of variation explained by each factor.
 A higher percentage being considered more important
\end_layout

\begin_layout Paragraph*
General 
\begin_inset Formula $2^{k}$
\end_inset

 designs
\series medium
.
 The results can be generalised under higher order operations like
\begin_inset Formula 
\begin{align*}
SST= & \,8(q_{A}+q_{B}+q_{C}+q_{AB}+q_{BC}+q_{AC}+q_{ABC})\\
= & \,(\text{SSA}+\text{SSB}+\text{SSC})+(\text{SSAB}+\text{SSBC}+\text{SSAC})+\text{SSABC}
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph
Fractional 
\begin_inset Formula $2^{k-p}$
\end_inset

designs
\end_layout

\begin_layout Itemize
\begin_inset Formula $2^{k}$
\end_inset

 requires 
\series bold
too many experiments
\series default
.
 We could decompose the problem with smaller subproblems with just a few
 interacting factors but can create issues.
\end_layout

\begin_layout Itemize
Adopt 
\begin_inset Formula $2^{k-p}$
\end_inset

 design with 
\begin_inset Formula $p$
\end_inset

 controlling the precision 
\series bold
assuming interaction among the factos are sparse
\series default
 and we can guess which ones they are.
 So we can replace interacting terms by other factors (
\begin_inset Formula $q_{AB}x_{A}x_{B}\rightarrow q_{C}x_{C}$
\end_inset

).

\series bold
 However ignoring interactions can bias the 
\begin_inset Formula $q_{i}$
\end_inset

 values!
\end_layout

\begin_layout Itemize

\series bold
Resolution of a fractional design
\series default
: Confounding means 
\begin_inset Formula $C$
\end_inset

 above is dependent on 
\begin_inset Formula $AB$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/confounding-1.png
	width 48line%

\end_inset


\begin_inset Graphics
	filename img/confounding-2.png
	width 48line%

\end_inset


\end_layout

\begin_layout Itemize
Here, column 
\begin_inset Formula $D=ABC$
\end_inset

 (1st and 3rd order - resolution 4).
 Can compute list of confoundings algorithmically (note that pointwise multiplic
ation of a column with itself will result in a vector of 1s):
\begin_inset Formula 
\[
D=ABC\Rightarrow D\circ D=A\circ ABC\Rightarrow I=ABCD
\]

\end_inset


\end_layout

\begin_layout Itemize
The minimum of the sum of the orders of the counfoudings (the minimum of
 the 
\series bold
resolutions
\series default
) means our design has a 
\series bold
resolution IV
\series default
 (in roman literals).
 The higher the resolution, the less severe the counfounding is.
\end_layout

\end_body
\end_document
