#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a5paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1cm
\topmargin 1.2cm
\rightmargin 1cm
\bottommargin 1.2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle empty
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
CO339 Performance Engineering
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard

\emph on
Perfomance engineering
\emph default
: Techniques applied to ensure the 
\series bold
non-functional requirements
\series default
 for perfomance.
 The key is defining a metric (Throughput, energy usage, etc.) and a threshold
 (target / budget).
 miuspe ale hting is no
\end_layout

\begin_layout Paragraph
Defining a target
\end_layout

\begin_layout Itemize

\series bold
Requirements
\series default
:
\series bold
 
\series default
Specific (numeric terms), Measurable, Acceptable (garantee success), Realisable,
 Thorough (covers everything)
\end_layout

\begin_layout Itemize

\series bold
Quality of Service (QoS)
\series default
: Value of a metric that must hold under certain assumptions / conditions.
 Can conflict with functional requirements.
\end_layout

\begin_layout Itemize

\series bold
Service Level Agreement (SLAs)
\series default
: Legal contracts specifying QoS objectives and penalties for violation.
 Enforced by constant monitoring (but not 
\emph on
continuous
\emph default
 â€“ cost)
\end_layout

\begin_layout Paragraph
Performance Evaluation techniques
\end_layout

\begin_layout Itemize

\series bold
Measuring
\series default
: Performed on prototype / final system.
 Good accuracy, often based on instrumentation.
 Costly and difficult to perform.
\end_layout

\begin_layout Itemize

\series bold
Benchmark
\series default
: Apply workload after getting system into a predefined state.
 Workload generator has to be at least as good as the system being benchmarked.
 Types of workloads:
\end_layout

\begin_deeper
\begin_layout Itemize
Batch (like a query set).
 Analyse 
\series bold
throughput
\series default
.
\end_layout

\begin_layout Itemize
Interactive (generate random queries).
 Analyse 
\series bold
latency
\series default
.
\end_layout

\begin_layout Itemize
Hybrids (random access in query set).
 
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Parameters
\series default
: 
\emph on
System parameters
\emph default
 (caches, CPU instruction costs, etc.).
 
\emph on
Workload parameters
\emph default
 (users, available memory, etc.), often continuous.
\end_layout

\begin_layout Itemize

\series bold
Statistic
\series default
: Aggregate multiple runs with variance to eliminate the noise.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Utilisation
\series default
: % of resource that is used to perform this service
\end_layout

\begin_layout Itemize

\series bold
Bottleneck
\series default
: The resource with the highest utilisation
\end_layout

\end_deeper
\begin_layout Paragraph
Improving performance
\end_layout

\begin_layout Itemize

\series bold
Goal
\series default
: Alternative designs (
\emph on
development
\emph default
) select best value for parameter (
\emph on
tuning
\emph default
).
\end_layout

\begin_layout Itemize

\series bold
Analytical modeling
\series default
: Mathematical relationship between performance parameters and performance
 metrics.
 
\emph on
How to model dynamic system with static equations?
\emph default
 Fast, allow what-if analysis.
\end_layout

\begin_layout Itemize

\series bold
Simulation
\series default
: When system is too complex to be understood.
 Slow experiments.
\end_layout

\begin_layout Paragraph
Parameter tuning
\series medium
.
 Find optimal parameter vector to maximise performance metric & minimise
 the resource consumption.
 Sometimes means trading the use of expensive / non-scalable resource by
 using more of others.
\end_layout

\begin_layout Section
Performance profiling & tracing
\end_layout

\begin_layout Standard

\emph on
Profile
\emph default
: A graphical or other reprentation charactising the system in terms of
 the time it spends in certain states.
 Can be used to identify critical paths, bottlenecks or help tuning.
\end_layout

\begin_layout Paragraph
Events
\series medium
.
 A change in the system.
 Simple (clock tick), complex (cache miss).
 
\end_layout

\begin_layout Itemize

\series bold
Collecting events
\series default
.
 
\series bold
Tracing
\series default
 (keep state for every event, high overhead, more information), 
\series bold
Sampling
\series default
 (keep state in intervals, often time based, inaccurate).
 Sampling with size 1 is event based (counting number of occurences).
\end_layout

\begin_layout Itemize

\series bold
Making a profile
\series default
: Aggregating over the events of a specific metric/
\end_layout

\begin_layout Itemize

\series bold
Trace
\series default
: Ordered log of every state.
 Example with stack call tracing, aggregated in flame graph.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/event-classification.png
	width 90page%

\end_inset


\end_layout

\begin_layout Paragraph
Collecting events
\series medium
.
 Want detailed and accurate measurements whilst limiting the perturbation
 in the system.
 Could collect with software (OS, compiler), hardware (counter) or creating
 an emulator.
\end_layout

\begin_layout Itemize

\series bold
Instrumentation
\series default
: Augment program with even logging code.
 No need for hardware supports and works regardless of admin right etc.
 Overhead and perturbation are high.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Automatic
\series default
 source level: libraries.
 Binary level: Usually compiler supported, less control.
 If static then always pay overhead whereas dynamic means no recompilation,
 can be performed on running process, JIT?
\end_layout

\begin_layout Itemize

\series bold
Manual
\series default
: Logging.
 +: Control, no special hardware or compiler needs.
 -: disabled for release builds, needs recompilation.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Performance counting
\series default
.
 Software (application specific/OS level -packets, context switch).
 Hardware (Often buggy and poorly documented).
\end_layout

\begin_layout Paragraph
CPU architecture
\end_layout

\begin_layout Itemize
Hardware are designed for certain classes of programs and full of hacks
 so optimisation isn't as easy as just making programs with less instructions
 and instead we have a 400 pages long Intel architectures optimisation ref
 manual.
\end_layout

\begin_layout Itemize

\series bold
Pipelining
\series default
: instructions on different stages are executed in parallel on the CPU.
 A 
\series bold
Control hazard
\series default
 means the pipeline is stopped because next intruction is conditional.
\end_layout

\begin_layout Itemize

\series bold
Caches
\series default
: 
\begin_inset Quotes eld
\end_inset

Hot
\begin_inset Quotes erd
\end_inset

 non-programmable memory.
 Organised in a hierarchy of increasing size.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/cache-locality.png
	width 43page%

\end_inset


\begin_inset Graphics
	filename img/hot-dataset.png
	width 43page%

\end_inset


\end_layout

\begin_layout Paragraph
Bottleneck analysis on CPU.
 
\series medium
Consists of checking micro-ops status.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename img/cpu-bottleneck-analysis.png
	width 50page%

\end_inset


\end_layout

\begin_layout Section
Applied performance modeling
\end_layout

\begin_layout Paragraph
System modeling.

\series medium
 Encompases 
\emph on
hardware
\emph default
, 
\emph on
code
\emph default
, 
\emph on
data
\emph default
/
\emph on
input
\emph default
 to get profile.
\end_layout

\begin_layout Itemize

\series bold
Numerical/experimental models
\series default
: Easy to get if system exists.
 Provides limited insights (not instructive nor interpretable outside of
 the context and so generalises poorly) and requires lots of experimental
 data.
\end_layout

\begin_layout Itemize

\series bold
Analytical models
\series default
: System doesn't need to exist, what-if analysis.
 It requires extensive validation and grows very complex to handle edge
 cases.
\end_layout

\begin_layout Paragraph
System parameters
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Variable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a General Purpose Register of the CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the Level 1 Cache (with processing time)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{0}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of a General Purpose Register of the CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a cache line of the Level 1 cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the Level 2 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of the Level 1 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a cache line of the Level 2 cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Access Latency of the main memory
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Capacity of the Level 2 Cache
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $B_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size of a Memory Page
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $I_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lookup time in the Page Table
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $C_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of Memory Pages in the TLB times Page size
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Static analysis
\series default
:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,tabsize=4"
inline false
status open

\begin_layout Plain Layout

extern int* input; extern size_t N; extern size_t stride;
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for (size_t i = 0; i < N; i+= stride) {
\end_layout

\begin_layout Plain Layout

	sum += input[stride];
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
\begin_inset Formula $s=\text{{stride}}$
\end_inset

, 
\begin_inset Formula $T_{mem}=\sum_{i=0}^{3}I_{i}\times\min(1,\frac{{s}}{B_{i}})$
\end_inset


\end_layout

\begin_layout Itemize

\series bold
Dynamic systems and state
\series default
.
 Stochastical models, in particular markov chains.
\end_layout

\begin_layout Paragraph
Modeling memory access
\end_layout

\begin_layout Itemize

\series bold
Parameters
\series default
: 
\begin_inset Formula $R_{n}$
\end_inset

 number of stored tuples, 
\begin_inset Formula $R_{w}$
\end_inset

(size of tuple in words).
 
\begin_inset Formula $||R||$
\end_inset

 (size of region) is product of length and width.
 
\begin_inset Formula $u$
\end_inset

 is number of word read in each access.
\end_layout

\begin_layout Itemize

\series bold
Composition
\series default
: 
\begin_inset Formula $P_{1}\oplus P_{2}$
\end_inset

 Serial execution of 
\begin_inset Formula $P_{1}$
\end_inset

,
\begin_inset Formula $P_{2}$
\end_inset

.
 
\begin_inset Formula $P_{1}\odot P_{2}$
\end_inset

 concurrent execution.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C"
inline false
status open

\begin_layout Plain Layout

// uniform random data, 1024 values
\end_layout

\begin_layout Plain Layout

extern struct{int a; int b; int c;}* input1;
\end_layout

\begin_layout Plain Layout

extern int* input2; // random data, 64 values
\end_layout

\begin_layout Plain Layout

int sum = 0; for(size_t i = 0; i < inputSize; i++) {
\end_layout

\begin_layout Plain Layout

	sum += input2[input1[i].a] >> 4;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\text{{s\_trav}(R.w = 3, u =1, R.n=1024)\odot\text{{rr\_acc}(R.w=1, u=1, R.n=64, r=1024)}}$
\end_inset


\end_layout

\begin_layout Paragraph
Assumptions
\series medium
.
 Assume distribution and independence of the input.
 Assume independent parallelism (cache contention etc.
 not discussed).
 Can't model noise.
\end_layout

\begin_layout Section
CPU efficient code
\end_layout

\begin_layout Paragraph
Metrics
\end_layout

\begin_layout Itemize

\series bold
Wall time
\series default
 is ultimate goal when Cycles Per Instructions is more of a parameter.
\end_layout

\begin_layout Itemize

\series bold
Stall cycles
\series default
 can be good but can miss the bigger picture, but help reduce:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Control
\emph default
 hazards: stalls due to data-dependent flow
\end_layout

\begin_layout Itemize

\emph on
Structural
\emph default
 hazards: stalls due to CPU's features
\end_layout

\begin_layout Itemize

\emph on
Data
\emph default
 hazards: stalls due to operands not being there on time.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
CPU efficiency
\series default
: proxy metrics
\end_layout

\begin_deeper
\begin_layout Itemize
Work-efficiency: Don't waste cycles
\end_layout

\begin_layout Itemize
Simplicity: Fewer instructions for less resource utilisation
\end_layout

\begin_layout Itemize
Parallelism: even in non parallel algorithms
\end_layout

\begin_layout Itemize
Predictability: ease speculation
\end_layout

\begin_layout Itemize
Adaptivity: acount for unknown parameters
\end_layout

\begin_layout Itemize
Specialization: use of hardware features
\end_layout

\begin_layout Itemize
Separation of Concerns: make hardware do heavy lifting
\end_layout

\end_deeper
\begin_layout Paragraph
Design decisions
\series medium
: Know the system's specifications, can it do out-of order / speculative
 execution? 
\emph on
Dynamic
\emph default
 parallelism (superscalar execution) or 
\emph on
statically
\emph default
 bundled (SIMD or Very long instruction word - VLIW)?
\end_layout

\begin_layout Paragraph
More architecture
\end_layout

\begin_layout Itemize

\series bold
Pipeline execution
\series default
: 
\begin_inset Formula $\neq$
\end_inset

instruction in 
\begin_inset Formula $\neq$
\end_inset

stages.
 Affected by
\emph on
 all 3
\emph default
 hazards
\end_layout

\begin_layout Itemize

\series bold
Superscalar execution
\series default
: 
\begin_inset Formula $\neq$
\end_inset

 instructions in same stage.
\end_layout

\begin_layout Itemize

\series bold
Out of order
\series default
: Exploits expression reordering and better ALU allocation.
 Suffers from 
\emph on
control
\emph default
 hazards.
\end_layout

\begin_layout Itemize

\series bold
Speculative execution
\series default
: Fills pipeline if no instruction is eligible.
 Addresses 
\emph on
control
\emph default
 hazard.
\end_layout

\begin_layout Itemize

\series bold
SIMD
\series default
: Vector registers can perform operation on set of values faster than one
 by one.
 Careful about clocking down CPU during that time though.
\end_layout

\begin_layout Itemize

\series bold
VLIW
\series default
: Instruction encoding multiple regular instructions.
\end_layout

\begin_layout Paragraph
Partial evaluation
\end_layout

\begin_layout Itemize

\series bold
Constant evaluation
\series default
: When scope allows it.
\end_layout

\begin_layout Itemize

\series bold
Lifting / eliminating expensive operations
\series default
: Don't do it by writting code for each cases, let the compiler do it (template
 meta-programming).
\end_layout

\begin_layout Itemize

\series bold
JIT compilation, inlining, symbolic programming.
\end_layout

\begin_layout Paragraph
Predicability
\series medium
.
 Very data dependent but code can be quite predicatable.
 Use 
\emph on
predication
\emph default
/if-conversion if measure indicates otherwise.
\end_layout

\begin_layout Paragraph
CPU in-core parallelism, do it in hardware.

\series medium
 Compilers try to auto-vectorise, if fail use Intel intrinsics (functions
 mapped to assembly).
\end_layout

\begin_layout Section
Memory efficient code
\end_layout

\begin_layout Paragraph
Data hazards
\end_layout

\begin_layout Itemize

\series bold
Cache misses
\series default
, the three Cs (plus 
\emph on
coherence
\emph default
 across cores)
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Compulsory
\emph default
: first access of the cache line
\end_layout

\begin_layout Itemize

\emph on
Capacity
\emph default
: Discarded value and retrived later
\end_layout

\begin_layout Itemize

\emph on
Conflict
\emph default
: Direct map and set-associative block-placement strategy
\end_layout

\end_deeper
\begin_layout Paragraph
Causes for data stalls (type) and solutions:
\end_layout

\begin_layout Itemize
Non compulsory 
\emph on
cache miss
\emph default
 (
\series bold
capacity bound
\series default
): Reduce hot dataset size
\end_layout

\begin_deeper
\begin_layout Itemize
Popular cache replacement strategy is 
\series bold
LRU
\series default

\begin_inset Formula $\rightarrow$
\end_inset

can cause 
\series bold
thrashing
\end_layout

\begin_layout Itemize

\series bold
Tile loops
\series default
 to decrease hot dataset size.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Fully utilised memory bus
\emph default
 (
\series bold
bandwidth bound
\series default
): Increase cache-line utilisation
\end_layout

\begin_layout Itemize
Otherwise compulsory misses (
\series bold
latency bound
\series default
): Prefetch
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

void __buildin_prefetch(const void *addr, ...);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Paragraph
Virtual memory (hardware optimise to reduce latency)
\end_layout

\begin_layout Itemize

\series bold
Address translation
\series default
: CPU deals in virtual addresses.
 Addresses in cache are 
\emph on
virtually indexed
\emph default
 and 
\emph on
physically tagged
\emph default
 (VIPT).
 Translation Lookaside Buffer (
\emph on
TLB
\emph default
) caches translations, page fault is interupt.
\end_layout

\begin_layout Itemize

\series bold
Memory allocation
\series medium
.
 Difference between once, eager, and lazy (reallocation) is caused by 
\series bold
Copy on Write
\series medium
.
\end_layout

\begin_layout Itemize
What happens when a prefetch causes a TLB miss (
\series bold
page fault
\series default
) ? Fetching page should cause OS interupt (resolve synonyms by page colouring,
 set up CoW etc.) so shouldn't prefetch.
\end_layout

\begin_layout Paragraph*
Multicore effect and coherance.

\series medium
 
\emph on
MESI
\emph default
 to coordinate caches in QPI (Intel quickpath interconnect).
 Cache lines can cause false sharing (writing to same line but different
 addresses), slowdown of 
\begin_inset Formula $\approx0.85T$
\end_inset

x where 
\begin_inset Formula $T$
\end_inset

 is number of cores.
\end_layout

\end_body
\end_document
